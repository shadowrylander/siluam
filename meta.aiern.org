#+setupfile: ./settings/README.org
#+include: ./settings/README.org
#+property: header-args:emacs-lisp+ :comments none

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* .gitconfig

#+begin_src conf :tangle (meq/tangle-path)
[remote "settings"]
	url = https://github.com/<<username>>/settings.git
	fetch = +refs/heads/main:refs/remotes/origin/main
	pushurl = git@github.com:<<username>>/settings.git
[remote "borg"]
	url = https://github.com/emacscollective/borg.git
	fetch = +refs/heads/master:refs/remotes/origin/master
[remote "epkg"]
	url = https://github.com/emacscollective/epkg.git
	fetch = +refs/heads/master:refs/remotes/origin/master
[remote "closql"]
	url = https://github.com/emacscollective/closql.git
	fetch = +refs/heads/master:refs/remotes/origin/master
[remote "emacsql"]
	url = https://github.com/skeeto/emacsql.git
	fetch = +refs/heads/master:refs/remotes/origin/master
#+end_src

* pre-borg.mk

#+begin_src makefile :tangle (meq/tangle-path)
BORG_SECONDARY_P = true
include $(shell find -L elpa -maxdepth 1 -regex '.*/borg-[.0-9]*' |\
  sort | tail -n 1)/borg.mk
#+end_src

* borg.mk

#+begin_Src makefile :tangle (meq/tangle-path)
DRONES_DIR = $(shell git config "borg.drones-directory" || echo "lib")

-include $(DRONES_DIR)/borg/borg.mk

bootstrap-borg:
		@git submodule--helper clone --name borg --path $(DRONES_DIR)/borg \
		--url git@github.com:emacscollective/borg.git
		@cd $(DRONES_DIR)/borg; git symbolic-ref HEAD refs/heads/master
		@cd $(DRONES_DIR)/borg; git reset --hard HEAD
#+end_src

* makefile

#+begin_src makefile :tangle (meq/tangle-path)
.RECIPEPREFIX := |
.DEFAULT_GOAL := emacs
SHELL := /usr/bin/env xonsh

# Adapted From: https://www.systutorials.com/how-to-get-the-full-path-and-directory-of-a-makefile-itself/
mkfilePath := $(abspath $(lastword $(MAKEFILE_LIST)))
mkfileDir := $(dir $(mkfilePath))

init: pre-init tangle

pre-init:
|-fd . -HIt d -t e -x rm -rf
|-git -C $(mkfileDir) config include.path "$(mkfileDir)/.gitconfig"

tangle-setup:
|cp $(mkfileDir)/settings/org-tangle.sh $(mkfileDir)/settings/backup-tangle.sh
|chmod +x $(mkfileDir)/settings/org-tangle.sh $(mkfileDir)/settings/backup-tangle.sh

tangle: tangle-setup
|yes yes | fd . $(mkfileDir) \
    -HId 1 -e org \
    -E testing.aiern.org \
    -E resting.aiern.org \
    -x $(mkfileDir)/settings/backup-tangle.sh
|fd . $(mkfileDir)/settings \
    -HIe sh \
    -x chmod +x

subinit: init
|-git clone --depth 1 https://github.com/emacsmirror/epkgs.git $(mkfileDir)/epkgs
|-git -C $(mkfileDir)/epkgs checkout master
|-git clone --depth 1 https://github.com/emacsmirror/epkgs.git $(mkfileDir)/var/epkgs
|-git -C $(mkfileDir)/var/epkgs checkout master

# Adapted From:
# Answer: https://stackoverflow.com/a/56621295/10827766
# User: https://stackoverflow.com/users/1600536/alim-giray-aytar
|git -C $(mkfileDir) submodule update --init --depth 1 --recursive --remote

|git -C $(mkfileDir) submodule sync
# |git -C $(mkfileDir) submodule foreach 'git -C $$toplevel config submodule.$$name.ignore all'

pull: subinit
|git -C $(mkfileDir) pull

add:
|git -C $(mkfileDir) add .

commit:
|-git -C $(mkfileDir) commit --allow-empty-message -am ""

cammit: init add commit

push: cammit
|-git -C $(mkfileDir) push

super-push: tangle push

include tests.mk
#+end_src

* tests.mk

#+begin_src makefile :tangle (meq/tangle-path)
.RECIPEPREFIX := |
.DEFAULT_GOAL := emacs
SHELL := /usr/bin/env xonsh
test := emacs --bg-daemon=test
killTest := emacsclient -s test -e "(kill-emacs)"
profile = $(shell cat $(mkfileDir)/default.aiern.org)

pre-test: subinit

pest: pre-test
|emacs -p

no-config-test:
|emacs -Q

test-and-kill-pre: pre-test
|-emacsclient -s test -e "(kill-emacs)"

test-new-and-kill: test-and-kill-pre
|$(test) -Q
|$(killTest)

test-new-nw-and-kill: test-and-kill-pre
|$(test) -Q -nw
|$(killTest)

clean-all:
|fd . $(mkfileDir) -HIe elc -x rm

pre-clean:
|fd . $(mkfileDir) -HId 1 -e elc -x rm

clean: pre-clean
|fd . $(mkfileDir)/profiles/$(profile) -HIe elc -x rm

delete: clean
|rm -rf $(mkfileDir)/profiles/$(profile)/.local

test: pre-test
|emacs --profile $(profile)

nw-test: pre-test
|emacs -nw --profile $(profile)

test-and-kill: test-and-kill-pre
|$(test) --profile $(profile)
|$(killTest)

test-nw-and-kill: test-and-kill-pre
|$(test) -nw --profile $(profile)
|$(killTest)

test-update-and-kill: test-and-kill-pre
|$(test) --update --profile $(profile)
|$(killTest)

test-nw-update-and-kill: test-and-kill-pre
|$(test) -nw --update --profile $(profile)
|$(killTest)

emacs: test
emacs-nw: nw-test
remacs: delete emacs
remacs-nw: delete emacs-nw
#+end_src

* siluam
** damascus.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; damascus.el --- a simple package                     -*- lexical-binding: t; -*-

;; Copyright (C) 2021  Jeet Ray

;; Author: Jeet Ray <aiern@protonmail.com>
;; Keywords: lisp
;; Version: 0.0.1

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Put a description of the package here

;;; Code:

;; code goes here

(provide 'damascus)
;;; damascus.el ends here
#+end_src


** eyedropper.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; eyedropper.el --- Pick foreground and background colors at cursor or pointer.
;;
;; Filename: eyedropper.el
;; Description: Pick foreground and background colors at cursor or pointer.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2006-2018, Drew Adams, all rights reserved.
;; Created: Fri Jun 23 08:07:15 2006
;; Version: 0
;; Package-Requires: ((hexrgb "0"))
;; Last-Updated: Mon Jan  1 11:15:31 2018 (-0800)
;;           By: dradams
;;     Update #: 200
;; URL: https://www.emacswiki.org/emacs/download/eyedropper.el
;; Doc URL: https://www.emacswiki.org/emacs/CustomizingFaces
;; Keywords: color, rgb, hsv, hexadecimal, face, frame
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `hexrgb'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;  Use the commands defined here to examine or save the background or
;;  foreground color at the text cursor or the mouse pointer.
;;
;;  After using commands `eyedrop-pick-background-*' or
;;  `eyedrop-pick-foreground-*', the picked color is saved in variable
;;  `eyedrop-picked-background' or `eyedrop-picked-foreground',
;;  respectively.
;;
;;  If you have Emacs 22 or later, all of the functionality provided
;;  here, and much more, is provided in library `palette.el'.  Use
;;  library `eyedropper' instead of `palette.el' if either of these
;;  applies:
;;
;;  * You do not want to use the color palette itself.  You want only
;;    the functionality provided by `eyedropper.el'.
;;
;;  * Your Emacs version is older than Emacs 22 (`palette.el' requires
;;    22 or later).
;;
;;  If you load `palette.el', there is no reason to also load
;;  `eyedropper.el'.  However, if for some reason you do load both
;;  `palette.el' and `eyedropper.el' then load `palette.el' second, so
;;  that its definitions will override those provided in
;;  `eyedropper.el', providing additional functionality for the color
;;  palette.
;;
;;  To use this library:
;;
;;    Add this to your initialization file (~/.emacs or ~/_emacs):
;;
;;      (require 'eyedropper) ; Load this library.
;;
;;    You will also need my library `hexrgb.el'; it is loaded
;;    automatically by `eyedropper.el'.  Get it here:
;;    https://www.emacswiki.org/emacs/download/hexrgb.el.
;;
;;  Commands defined here:
;;
;;    `background-color', `eyedrop-background-at-mouse',
;;    `eyedrop-background-at-point', `eyedrop-foreground-at-mouse',
;;    `eyedrop-foreground-at-point', `eyedropper-background',
;;    `eyedropper-foreground', `eyedrop-pick-background-at-mouse',
;;    `eyedrop-pick-background-at-point',
;;    `eyedrop-pick-foreground-at-mouse',
;;    `eyedrop-pick-foreground-at-point', `foreground-color',
;;    `pick-background-color', `pick-foreground-color'.
;;
;;  Non-interactive functions defined here:
;;
;;    `eyedrop-color-message', `eyedrop-face-at-point', `keywordp'.
;;
;;  Internal variables defined here:
;;
;;    `eyedrop-last-picked-color', `eyedrop-picked-background',
;;    `eyedrop-picked-foreground'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2015/05/09 dadams
;;     eyedrop-(background|foreground)-at-point: Reverse params to and in last let clause.
;; 2013/11/15 dadams
;;     eyedrop-(fore|back)ground-at-point: Return nil if unspecified-(fg|bg).
;; 2012/08/12 dadams
;;     eyedrop-(background|foreground)-at-mouse: Ignore a switch-frame event.
;; 2011/01/04 dadams
;;     Added autoload cookies for commands.
;; 2007/10/11 dadams
;;     eyedrop-(back|fore)ground-at-(mouse|point),
;;     eyedrop-pick-(back|fore)ground-at-(mouse|point), pick-(back|fore)ground-color:
;;       Added optional MSG-P arg (instead of interactive-p).
;; 2006/07/28 dadams
;;     eyedrop-face-at-point: Use car, not caar, for (*-color . "...") test.
;; 2006/06/25 dadams
;;     Added: eyedrop-last-picked-color.  Set it whenever set picked fg or bg.
;; 2006/06/24 dadams
;;     Added: keywordp (for Emacs 20), eyedrop-face-at-point.
;;     eyedrop-(back|fore)ground-at-point: Use eyedrop-face-at-point also.
;; 2006/06/23 dadams
;;     Created.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'hexrgb) ;; hexrgb-hex-to-rgb, hexrgb-rgb-to-hsv

;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar eyedrop-picked-background nil
  "Color last picked from a face or frame background.
You can use `eyedrop-pick-background-at-point' or
`eyedrop-pick-background-at-mouse' to pick the color.")

(defvar eyedrop-picked-foreground nil
  "Color last picked from a face or frame foreground.
You can use `eyedrop-pick-foreground-at-point' or
`eyedrop-pick-foreground-at-mouse' to pick the color.")

(defvar eyedrop-last-picked-color nil
  "Color last picked from a face or frame foreground or background.")

;; This is built-in in Emacs 21; not defined before Emacs 21.
(unless (fboundp 'keywordp)
  (defun keywordp (object)
    "Return t if OBJECT is a keyword.
This means that it is a symbol with a print name beginning with `:'
interned in the initial obarray."
    (and (symbolp object) (string-match "^:" (symbol-name object)) t)))

(defun eyedrop-color-message (color)
  "Display information about COLOR as a message."
  (let* ((rgb (hexrgb-hex-to-rgb color))
         (hsv (apply #'hexrgb-rgb-to-hsv rgb)))
    (message (format "Color: %s, RGB: %s, HSV: %s" color rgb hsv)))
  color)                                ; Return it.

;;;###autoload
(defun eyedrop-background-at-mouse (event &optional msg-p)
  "Return the background color under the mouse pointer.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
  (while (input-pending-p) (discard-input))
  ;; Ignore `switch-frame' events.
  (when (and (consp event)  (eq (event-basic-type (car event)) 'switch-frame))
    (setq event  (read-event)))
  (set-buffer (window-buffer (posn-window (event-end event))))
  (mouse-set-point event)
  (let ((bg (eyedrop-background-at-point)))
    (when msg-p (if bg (eyedrop-color-message bg) (message "No background color here")))
    bg))

;;;###autoload
(defun eyedrop-foreground-at-mouse (event &optional msg-p)
  "Return the foreground color under the mouse pointer.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
  (while (input-pending-p) (discard-input))
  ;; Ignore `switch-frame' events.
  (when (and (consp event)  (eq (event-basic-type (car event)) 'switch-frame))
    (setq event  (read-event)))
  (set-buffer (window-buffer (posn-window (event-end event))))
  (mouse-set-point event)
  (let ((fg (eyedrop-foreground-at-point)))
    (when msg-p (if fg (eyedrop-color-message fg) (message "No foreground color here")))
    fg))

;; RMS added this function to Emacs (23) as `face-at-point'.
(defun eyedrop-face-at-point ()
  "Return the face under the text cursor.
If there is more than one face, return the first one.
Return nil if there is no face at point."
  (let* ((faceprop (or (get-char-property (point) 'read-face-name)
                       (get-char-property (point) 'face)
                       'default))
         (face (cond ((symbolp faceprop) faceprop)
                     ;; List of faces (don't treat an attribute spec).
                     ;; Just use the first face.
                     ((and (consp faceprop) (not (keywordp (car faceprop)))
                           (not (memq (car faceprop) '(foreground-color background-color))))
                      (car faceprop))
                     (t nil))))         ; Invalid face value.
    (if (facep face) face nil)))

;; RMS added this function to Emacs (23) as `background-color-at-point'.
;;;###autoload
(defalias 'background-color 'eyedrop-background-at-point)
;;;###autoload
(defun eyedrop-background-at-point (&optional msg-p)
  "Return the background color under the text cursor.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  ;; `eyedrop-face-at-point' alone is not sufficient.  It only gets named faces.
  ;; Need also pick up any face properties that are not associated with named faces.
  (let* ((face  (or (eyedrop-face-at-point)
                    (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face)))
         (bg    (cond ((and face (symbolp face))
                       (condition-case nil
                           (face-background face nil 'default) ; Emacs 22+.
                         (error (or (face-background face) ; Emacs 20
                                    (cdr (assq 'background-color (frame-parameters)))))))
                      ((consp face)
                       (cond ((memq 'background-color face)
                              (cdr (memq 'background-color face)))
                             ((memq ':background face)
                              (cadr (memq ':background face)))))
                      (t nil)))         ; Invalid face value.
         (bg    (and (not (member bg '("unspecified-fg" "unspecified-bg")))  bg)))
    (when msg-p
      (if bg (eyedrop-color-message bg) (message "No background color here")))
    bg))

;; RMS added this function to Emacs (23) as `foreground-color-at-point'.
;;;###autoload
(defalias 'foreground-color 'eyedrop-foreground-at-point)
;;;###autoload
(defun eyedrop-foreground-at-point (&optional msg-p)
  "Return the foreground color under the text cursor.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  ;; `eyedrop-face-at-point' alone is not sufficient.  It only gets named faces.
  ;; Need also pick up any face properties that are not associated with named faces.
  (let* ((face  (or (eyedrop-face-at-point)
                    (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face)))
         (fg    (cond ((and face (symbolp face))
                       (condition-case nil
                           (face-foreground face nil 'default) ; Emacs 22+.
                         (error (or (face-foreground face) ; Emacs 20
                                    (cdr (assq 'foreground-color (frame-parameters)))))))
                      ((consp face)
                       (cond ((memq 'foreground-color face)
                              (cdr (memq 'foreground-color face)))
                             ((memq ':foreground face)
                              (cadr (memq ':foreground face)))))
                      (t nil)))         ; Invalid face value.
         (fg    (and (not (member fg '("unspecified-fg" "unspecified-bg")))  fg)))
    (when msg-p
      (if fg (eyedrop-color-message fg) (message "No foreground color here")))
    fg))

;;;###autoload
(defun eyedrop-pick-background-at-mouse (event &optional msg-p)
  "Pick background of face or frame at character under the mouse pointer.
Save the background color in `eyedrop-picked-background' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  (setq eyedrop-picked-background (eyedrop-background-at-mouse event)
        eyedrop-last-picked-color eyedrop-picked-background)
  (unless (stringp eyedrop-picked-background) (error "No background color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-background))
  eyedrop-picked-background)

;;;###autoload
(defun eyedrop-pick-foreground-at-mouse (event &optional msg-p)
  "Pick foreground of face or frame at character under the mouse pointer.
Save the foreground color in `eyedrop-picked-foreground' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  (setq eyedrop-picked-foreground (eyedrop-foreground-at-mouse event)
        eyedrop-last-picked-color eyedrop-picked-foreground)
  (unless (stringp eyedrop-picked-foreground) (error "No foreground color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-foreground))
  eyedrop-picked-foreground)

;;;###autoload
(defalias 'eyedropper-background 'eyedrop-pick-background-at-point)
;;;###autoload
(defalias 'pick-background-color 'eyedrop-pick-background-at-point)
;;;###autoload
(defun eyedrop-pick-background-at-point (&optional msg-p)
  "Pick background of face or frame at character at text cursor (point).
Save the background color in `eyedrop-picked-background' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  (setq eyedrop-picked-background (eyedrop-background-at-point)
        eyedrop-last-picked-color eyedrop-picked-background)
  (unless (stringp eyedrop-picked-background) (error "No background color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-background))
  eyedrop-picked-background)

;;;###autoload
(defalias 'eyedropper-foreground 'eyedrop-pick-foreground-at-point)
;;;###autoload
(defalias 'pick-foreground-color 'eyedrop-pick-foreground-at-point)
;;;###autoload
(defun eyedrop-pick-foreground-at-point (&optional msg-p)
  "Pick foreground of face or frame at character at text cursor (point).
Save the foreground color in `eyedrop-picked-foreground' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  (setq eyedrop-picked-foreground (eyedrop-foreground-at-point)
        eyedrop-last-picked-color eyedrop-picked-foreground)
  (unless (stringp eyedrop-picked-foreground) (error "No foreground color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-foreground))
  eyedrop-picked-foreground)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide 'eyedropper)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; eyedropper.el ends here
#+end_src

** fringe.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; fringe.el --- fringe setup and control  -*- coding: utf-8 -*-

;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008,
;;   2009 Free Software Foundation, Inc.

;; Author: Simon Josefsson <simon@josefsson.org>
;; Maintainer: FSF
;; Keywords: frames

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This file contains code to initialize the built-in fringe bitmaps
;; as well as helpful functions for customizing the appearance of the
;; fringe.

;; The code is influenced by scroll-bar.el and avoid.el.  The author
;; gratefully acknowledge comments and suggestions made by Miles
;; Bader, Eli Zaretski, Richard Stallman, Pavel JanÃ­k and others which
;; improved this package.

;;; Code:

(defgroup fringe nil
  "Window fringes."
  :version "22.1"
  :group 'frames)

;; Define the built-in fringe bitmaps and setup default mappings

(when (boundp 'fringe-bitmaps)
  (let ((bitmaps '(question-mark
		   left-arrow right-arrow up-arrow down-arrow
		   left-curly-arrow right-curly-arrow
		   left-triangle right-triangle
		   top-left-angle top-right-angle
		   bottom-left-angle bottom-right-angle
		   left-bracket right-bracket
		   filled-rectangle hollow-rectangle
		   filled-square hollow-square
		   vertical-bar horizontal-bar
		   empty-line))
	(bn 1))
    (while bitmaps
      (push (car bitmaps) fringe-bitmaps)
      (put (car bitmaps) 'fringe bn)
      (setq bitmaps (cdr bitmaps)
	    bn (1+ bn))))

  (setq-default fringe-indicator-alist
		'((truncation . (left-arrow right-arrow))
		  (continuation . (left-curly-arrow right-curly-arrow))
		  (overlay-arrow . right-triangle)
		  (up . up-arrow)
		  (down . down-arrow)
		  (top . (top-left-angle top-right-angle))
		  (bottom . (bottom-left-angle bottom-right-angle
			     top-right-angle top-left-angle))
		  (top-bottom . (left-bracket right-bracket
				 top-right-angle top-left-angle))
		  (empty-line . empty-line)
		  (unknown . question-mark)))

  (setq-default fringe-cursor-alist
		'((box . filled-rectangle)
		  (hollow . hollow-rectangle)
		  (bar . vertical-bar)
		  (hbar . horizontal-bar)
		  (hollow-small . hollow-square))))


(defmacro fringe-bitmap-p (symbol)
  "Return non-nil if SYMBOL is a fringe bitmap."
  `(get ,symbol 'fringe))


;; Control presence of fringes

(defvar fringe-mode)

(defvar fringe-mode-explicit nil
  "Non-nil means `set-fringe-mode' should really do something.
This is nil while loading `fringe.el', and t afterward.")

(defun set-fringe-mode-1 (ignore value)
  "Call `set-fringe-mode' with VALUE.
See `fringe-mode' for valid values and their effect.
This is usually invoked when setting `fringe-mode' via customize."
  (set-fringe-mode value))

(defun set-fringe-mode (value)
  "Set `fringe-mode' to VALUE and put the new value into effect.
See `fringe-mode' for possible values and their effect."
  (setq fringe-mode value)

  (when fringe-mode-explicit
    (modify-all-frames-parameters
     (list (cons 'left-fringe (if (consp fringe-mode)
				  (car fringe-mode)
				fringe-mode))
	   (cons 'right-fringe (if (consp fringe-mode)
				   (cdr fringe-mode)
				 fringe-mode))))))

;; For initialization of fringe-mode, take account of changes
;; made explicitly to default-frame-alist.
(defun fringe-mode-initialize (symbol value)
  (let* ((left-pair (assq 'left-fringe default-frame-alist))
	 (right-pair (assq 'right-fringe default-frame-alist))
	 (left (cdr left-pair))
	 (right (cdr right-pair)))
    (if (or left-pair right-pair)
	;; If there's something in default-frame-alist for fringes,
	;; don't change it, but reflect that into the value of fringe-mode.
	(progn
	  (setq fringe-mode (cons left right))
	  (if (equal fringe-mode '(nil . nil))
	      (setq fringe-mode nil))
	  (if (equal fringe-mode '(0 . 0))
	      (setq fringe-mode 0)))
      ;; Otherwise impose the user-specified value of fringe-mode.
      (custom-initialize-reset symbol value))))

(defcustom fringe-mode nil
  "Specify appearance of fringes on all frames.
This variable can be nil (the default) meaning the fringes should have
the default width (8 pixels), it can be an integer value specifying
the width of both left and right fringe (where 0 means no fringe), or
a cons cell where car indicates width of left fringe and cdr indicates
width of right fringe (where again 0 can be used to indicate no
fringe).
To set this variable in a Lisp program, use `set-fringe-mode' to make
it take real effect.
Setting the variable with a customization buffer also takes effect.
If you only want to modify the appearance of the fringe in one frame,
you can use the interactive function `set-fringe-style'."
  :type '(choice (const :tag "Default width" nil)
		 (const :tag "No fringes" 0)
		 (const :tag "Only right" (0 . nil))
		 (const :tag "Only left" (nil . 0))
		 (const :tag "Half width" (5 . 5))
		 (const :tag "Minimal" (1 . 1))
		 (integer :tag "Specific width")
		 (cons :tag "Different left/right sizes"
		       (integer :tag "Left width")
		       (integer :tag "Right width")))
  :group 'fringe
  :require 'fringe
  :initialize 'fringe-mode-initialize
  :set 'set-fringe-mode-1)

;; We just set fringe-mode, but that was the default.
;; If it is set again, that is for real.
(setq fringe-mode-explicit t)

(defun fringe-query-style (&optional all-frames)
  "Query user for fringe style.
Returns values suitable for left-fringe and right-fringe frame parameters.
If ALL-FRAMES, the negation of the fringe values in
`default-frame-alist' is used when user enters the empty string.
Otherwise the negation of the fringe value in the currently selected
frame parameter is used."
  (let ((mode (intern (completing-read
		       (concat
			"Select fringe mode for "
			(if all-frames "all frames" "selected frame")
			" (type ? for list): ")
		       '(("none") ("default") ("left-only")
			 ("right-only") ("half") ("minimal"))
		       nil t))))
    (cond ((eq mode 'none) 0)
	  ((eq mode 'default) nil)
	  ((eq mode 'left-only) '(nil . 0))
	  ((eq mode 'right-only) '(0 . nil))
	  ((eq mode 'half) '(5 . 5))
	  ((eq mode 'minimal) '(1 . 1))
	  ((eq mode (intern ""))
	   (if (eq 0 (cdr (assq 'left-fringe
				(if all-frames
				    default-frame-alist
				  (frame-parameters (selected-frame))))))
	       nil
	     0)))))

(defun fringe-mode (&optional mode)
  "Set the default appearance of fringes on all frames.

When called interactively, query the user for MODE.  Valid values
for MODE include `none', `default', `left-only', `right-only',
`minimal' and `half'.

When used in a Lisp program, MODE can be a cons cell where the
integer in car specifies the left fringe width and the integer in
cdr specifies the right fringe width.  MODE can also be a single
integer that specifies both the left and the right fringe width.
If a fringe width specification is nil, that means to use the
default width (8 pixels).  This command may round up the left and
right width specifications to ensure that their sum is a multiple
of the character width of a frame.  It never rounds up a fringe
width of 0.

Fringe widths set by `set-window-fringes' override the default
fringe widths set by this command.  This command applies to all
frames that exist and frames to be created in the future.  If you
want to set the default appearance of fringes on the selected
frame only, see the command `set-fringe-style'."
  (interactive (list (fringe-query-style 'all-frames)))
  (set-fringe-mode mode))

(defun set-fringe-style (&optional mode)
  "Set the default appearance of fringes on the selected frame.

When called interactively, query the user for MODE.  Valid values
for MODE include `none', `default', `left-only', `right-only',
`minimal' and `half'.

When used in a Lisp program, MODE can be a cons cell where the
integer in car specifies the left fringe width and the integer in
cdr specifies the right fringe width.  MODE can also be a single
integer that specifies both the left and the right fringe width.
If a fringe width specification is nil, that means to use the
default width (8 pixels).  This command may round up the left and
right width specifications to ensure that their sum is a multiple
of the character width of a frame.  It never rounds up a fringe
width of 0.

Fringe widths set by `set-window-fringes' override the default
fringe widths set by this command.  If you want to set the
default appearance of fringes on all frames, see the command
`fringe-mode'."
  (interactive (list (fringe-query-style)))
  (modify-frame-parameters
   (selected-frame)
   (list (cons 'left-fringe (if (consp mode) (car mode) mode))
	 (cons 'right-fringe (if (consp mode) (cdr mode) mode)))))

(defsubst fringe-columns (side &optional real)
  "Return the width, measured in columns, of the fringe area on SIDE.
If optional argument REAL is non-nil, return a real floating point
number instead of a rounded integer value.
SIDE must be the symbol `left' or `right'."
  (funcall (if real '/ 'ceiling)
	   (or (funcall (if (eq side 'left) 'car 'cadr)
			(window-fringes))
	       0)
           (float (frame-char-width))))

(provide 'fringe)

;; arch-tag: 6611ef60-0869-47ed-8b93-587ee7d3ff5d
;;; fringe.el ends here
#+end_src

** help+20.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; help+20.el --- Extensions to `help.el' for Emacs 20.
;;
;; Filename: help+20.el
;; Description: Extensions to `help.el' for Emacs 20.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1999-2018, Drew Adams, all rights reserved.
;; Created: Tue Mar 16 14:18:11 1999
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Jan  1 13:12:09 2018 (-0800)
;;           By: dradams
;;     Update #: 2219
;; URL: https://www.emacswiki.org/emacs/download/help%2b20.el
;; Doc URL: https://emacswiki.org/emacs/HelpPlus
;; Keywords: help
;; Compatibility: GNU Emacs 20.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `fit-frame', `frame-fns', `info', `info+20',
;;   `misc-fns', `naked', `strings', `thingatpt', `thingatpt+',
;;   `wid-edit', `wid-edit+', `widget'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `help.el' for Emacs 20.
;;
;;  Commands defined here:
;;
;;    `describe-command', `describe-file', `describe-keymap',
;;    `describe-option', `describe-option-of-type',
;;    `help-on-click/key', `mouse-help-on-click',
;;    `mouse-help-on-mode-line-click', `pop-to-help-toggle',
;;    `view-emacs-lisp-news', `save-*Help*-buffer'.
;;
;;  Non-interactive functions defined here:
;;
;;    `help-custom-type', `help-on-click/key-lookup',
;;    `help-remove-duplicates', `help-value-satisfies-type-p',
;;    `help-var-inherits-type-p', `help-var-is-of-type-p',
;;    `help-var-matches-type-p', `help-var-val-satisfies-type-p',
;;    `remove-help-window'.
;;
;;  Internal variables defined here:
;;
;;    `help-origin-buffer'.
;;
;;
;;  ***** NOTE: The following functions defined in `help.el' have
;;              been REDEFINED HERE:
;;
;;  `describe-function', `describe-function-1', `describe-key',
;;  `describe-mode', `describe-project', `describe-variable',
;;  `help-mode', `help-with-tutorial', `locate-library',
;;  `view-emacs-FAQ', `view-emacs-news', `where-is'.
;;
;;
;;  ***** NOTE: The doc string for `help-for-help' has been
;;              REDEFINED HERE
;;              (see `make-help-screen help-for-help')
;;
;;  The following bindings are made here:
;;
;;    `q'          `View-quit' (in `help-mode')
;;    `C-h c'      `describe-command' (replaces `describe-key-briefly')
;;    `C-h o'      `describe-option'
;;    `C-h u'      `manual-entry'
;;    `C-h C-a'    `apropos'
;;    `C-h C-c'    `describe-key-briefly' (replaces `describe-copying')
;;    `C-h C-l'    `locate-library'
;;    `C-h C-n'    `view-emacs-lisp-news'
;;    `C-h C-o'    `describe-option-of-type'
;;    `C-h C-s'    `save-*Help*-buffer'
;;    `C-h RET'    `help-on-click/key'
;;    `C-h M-a'    `apropos-documentation'
;;    `C-h M-c'    `describe-copying' (replaces `C-h C-c')
;;    `C-h M-f'    `describe-file'
;;    `C-h M-k'    `describe-keymap'
;;    `C-h M-o'    `pop-to-help-toggle'
;;    `C-h M-C-a'  `tags-apropos'
;;    [mouse-1]    `mouse-help-on-click' (non-mode-line)
;;    [mouse-1]    `mouse-help-on-mode-line-click' (mode-line)
;;
;;  Suggested additional binding:
;;
;;   (global-set-key [f1] 'help-on-click/key)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2017/01/15 dadams
;;     Added redefinition of describe-function-1.  Handle Emacs bug from its own advice.
;; 2014/05/04 dadams
;;     Soft-require info+20.el (new) instead of info+.el.
;; 2012/09/24 dadams
;;     describe-file: Added optional arg NO-ERROR-P.
;; 2012/08/21 dadams
;;     Call tap-put-thing-at-point-props after load thingatpt+.el.
;; 2012/08/18 dadams
;;     Invoke tap-define-aliases-wo-prefix if thingatpt+.el is loaded.
;;     help-on-click/key: Use tap-symbol-at-point, not symbol-at-point, if defined.
;; 2012/01/11 dadams
;;     describe-variable: Remove * from beginning of doc string.
;; 2011/12/19 dadams
;;     help-with-tutorial, describe-variable: Use line-end-position, not end-of-line + point.
;;     describe-variable: if -> when.
;; 2011/10/07 dadams
;;     Added soft require of naked.el.
;;     describe-key, where-is, help-on-click/key-lookup: Use naked-key-description if available.
;; 2011/04/25 dadams
;;     describe-file: Incorporate autofile bookmark description.  Added optional arg.
;; 2011/03/31 dadams
;;     help-var-(matches|inherits)-type-p: Wrap string-match with save-match-data.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non-interactive function and define-key.
;; 2009/08/30 dadams
;;     describe-keymap: Don't print nil if the map has no doc.
;; 2008/08/19 dadams
;;     describe-keymap: Use insert instead of princ for map part.  Thx to Chong Yidong.
;; 2008/05/20 dadams
;;     describe-function: Different prompt if prefix arg.
;; 2008/03/02 dadams
;;     Moved describe-file here from misc-cmds.el.  Bound to C-h M-f.
;; 2008/01/17 dadams
;;     Removed soft require of icicles.el
;; 2007/12/25 dadams
;;     help-var-inherits-type-p:
;;       Recheck var-type match after set var-type to its car.
;;       Handle string (regexp) TYPES elements.
;;     help-value-satisfies-type-p: Skip type check for string type (regexp).
;;     help-var-is-of-type-p: Doc string.  Use help-var-matches-type-p.
;;     Added: help-var-matches-type-p.
;; 2007/12/24 dadams
;;     help-var-inherits-type-p: Recheck type match after set var-type to its car.
;;     Added: help-custom-type.
;; 2007/12/23 dadams
;;     help-var-is-of-type-p:
;;       Added MODE arg.  Use help-var-inherits-type-p, help-var-val-satisfies-type-p.
;;       Redefined as MODE choice, not just a simple or.  Treat more cases.
;;     Added: help-var-inherits-type-p, help-var-val-satisfies-type-p,
;;            help-value-satisfies-type-p.
;;     describe-option-of-type: Prefix arg means use mode inherit-or-value.
;; 2007/12/22 dadams
;;     help-var-is-of-type-p:
;;       Check supertypes also.  Use both :validate and :match.
;;       Wrap type check in condition-case. Use widget-put instead of plist-put.
;;     Added soft require of wid-edit+.el.
;; 2007/12/21 dadams
;;     help-var-is-of-type-p: Use :validate, not :match, for the test.
;; 2007/12/20 dadams
;;     Swapped C-o and M-o bindings.
;; 2007/12/15 dadams
;;     Bound C-h c to describe-command and C-h C-c to describe-key-briefly.
;; 2007/12/14 dadams
;;     Renamed library from help+.el to help+20.el.  New help+.el is for Emacs 22+.
;;     Removed commented Emacs 19 stuff.
;;     view-emacs-lisp-news, describe-(key|function|variable):
;;       Removed emacs-major-version test.
;;     Added: Redefinition of help-mode.
;;     Bound q in help-mode to View-quit.
;;     Don't require cl.el if before Emacs 20.
;; 2007/12/13 dadams
;;     help-on-click/key: Removed extra arg in call to message.
;;     help-for-help: Reordered help string.
;; 2007/12/09 dadams
;;     (make-help-screen help-for-help...): Rewrote help text.
;; 2007/12/07 dadams
;;     describe-variable: if OPTIONP, then allow custom-variable-p as well as user-variable-p.
;;     describe-option-of-type: Use "nil" as default value.
;; 2007/12/06 dadams
;;     describe-option-of-type:
;;       If nil type, all defcustom vars are candidates.  Use custom-variable-p, if available.
;;       Specific error if no such custom type.
;;     describe-option: Use both custom-variable-p and user-variable-p.
;; 2007/12/04 dadams
;;     Added: describe-option-of-type, help-remove-duplicates, help-var-is-of-type-p.
;;     Bound o to describe-option (no longer edit-options), M-o to describe-option-of-type,
;;       C-c to describe-command, M-c to describe-copying.
;; 2007/11/28 dadams
;;     Renamed describe-bindings-in-map to describe-keymap.  Added keymap's doc string.
;; 2007/11/27 dadams
;;     locate-library: Use icicle-read-string-completing, if available.
;;     Soft require Icicles.
;; 2007/11/22 dadams
;;     Added: describe-bindings-in-map.  Bound to C-h M-k.
;; 2007/10/17 dadams
;;     describe-(function|variable): Prefix arg means describe only commands or user options.
;;     Added: describe-(command|option).
;; 2007/09/04 dadams
;;     remove-windows-on -> delete-windows-on.  Removed require of frame-cmds.el.
;; 2006/12/08 dadams
;;     describe-variable: Fixed interactive case when symbol-nearest-point is not defined.
;; 2006/07/11 dadams
;;     Added: help-origin-buffer, pop-to-help-toggle.  Bound latter to C-h C-o globally
;; 2005/10/31 dadams
;;     Use nil as init-value arg in calls to completing-read, everywhere.
;; 2001/01/10 dadams
;;     Protected remove-windows-on via fboundp.
;; 1999/08/12 dadams
;;     Added doc strings for help-on-click/key(-lookup) and updated header.
;; 1999/04/09 dadams
;;     help-on-click/key: Treat mouse click on symbol via apropos.
;; 1999/04/08 dadams
;;     help-on-click/key: 1. Treat mouse menus.
;;                        2. Corrected: flush extra mode-line mouse events.
;; 1999/04/08 dadams
;;     help-on-click/key: Bound temp-buffer-show-function so use other win.
;; 1999/04/08 dadams
;;     1. Added binding: help-on-click/key.
;;     2. Added: make-help-screen help-for-help.
;;     3. help-on-click/key-lookup: show-*Help*-buffer.
;;     4. help-on-click/key: Prompt.  Corrected: event->key, show-*Help*-buffer.
;; 1999/04/07 dadams
;;     1. Added: (replacement) describe-key.
;;     2. Added: help-on-click/key-lookup, help-on-click/key.
;; 1999/04/06 dadams
;;     Added binding for save-*Help*-buffer.
;; 1999/04/06 dadams
;;     1. Added some key bindings: o, u, C-l, C-a, M-a, C-M-a.
;;     2. Added: save-*Help*-buffer.
;; 1999/03/31 dadams
;;     Protected symbol-nearest-point with fboundp.
;; 1999/03/17 dadams
;;     1. Added: remove-help-window, help-with-tutorial, describe-project,
;;        view-emacs-FAQ, view-emacs-news, describe-function, describe-variable,
;;        where-is, locate-library, view-emacs-lisp-news.
;;     2. help-iso-prefix: Treat unbound iso-transl-char-map error.  Removed
;;        highlighting.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'info nil t) ;; (no error if not found):
                      ;; Info-exit, Info-goto-node, Info-goto-emacs-key-command-node
(require 'info+20 nil t) ;; (no error if not found):
                         ;; Info-goto-emacs-key-command-node (returns found-p)
(require 'thingatpt nil t) ;; (no error if not found): symbol-at-point

(when (and (require 'thingatpt+ nil t);; (no error if not found)
           (fboundp 'tap-put-thing-at-point-props)) ; >= 2012-08-21
  (tap-define-aliases-wo-prefix)
  (tap-put-thing-at-point-props))
  ;;  symbol-nearest-point, tap-symbol-at-point

(require 'frame-fns nil t) ;; (no error if not found): 1-window-frames-on
(require 'wid-edit+ nil t) ;; (no error if not found):
                           ;; redefined color widget (for help-var-is-of-type-p)
(require 'naked nil t) ;; (no error if not found): naked-key-description

;; Get macro `make-help-screen' when this is compiled,
;; or run interpreted, but not when the compiled code is loaded.
(eval-when-compile
  (require 'help-macro nil t) ;; (no error if not found) make-help-screen
  (require 'help-macro+ nil t)) ;; (no error if not found): make-help-screen
;; (require 'icicles nil t) ;; (no error if not found): icicle-read-string-completing


;; Quiet the byte-compiler.
(defvar view-no-disable-on-exit)
(defvar view-exit-action)

;;;;;;;;;;;;;;;;;;;;

(defvar help-origin-buffer nil "Buffer that we left, to go to *Help*.")

(define-key help-map "c" 'describe-command)
(define-key help-map "o" 'describe-option)
(define-key help-map "u" 'manual-entry) ; in `man.el'
(define-key help-map "\C-a" 'apropos)
(define-key help-map "\C-c" 'describe-key-briefly)
(define-key help-map "\C-l" 'locate-library)
(define-key help-map [?\C-m] 'help-on-click/key) ; RET
(define-key help-map [?\C-n] 'view-emacs-lisp-news)
(define-key help-map "\C-o" 'describe-option-of-type)
(define-key help-map "\C-s" 'save-*Help*-buffer)
(define-key help-map "\M-a" 'apropos-documentation)
(define-key help-map "\M-c" 'describe-copying)
(define-key help-map "\M-f" 'describe-file)
(define-key help-map "\M-k" 'describe-keymap)
(define-key help-map "\M-o" 'pop-to-help-toggle)
(define-key help-map "\M-\C-a" 'tags-apropos)
(define-key help-map [down-mouse-1] 'mouse-help-on-click)
(define-key help-map [mode-line down-mouse-1] 'mouse-help-on-mode-line-click)

;; `help-mode' too needs a quit key.
(define-key help-mode-map "q" 'View-quit)


(defsubst remove-help-window ()
  "If called from `help-for-help', remove display of help window."
  (when (eq 'help-for-help this-command) (delete-windows-on "*Help*")))


;; REPLACES ORIGINAL in `help.el':
;; Deletes *Help* frame when done, if `one-window-p'.
;;
;;;###autoload
(defun help-mode ()
  "Major mode for viewing help text and navigating references in it.
Entry to this mode runs the normal hook `help-mode-hook'.
Commands:
\\{help-mode-map}"
  (interactive)
  (kill-all-local-variables)
  (use-local-map help-mode-map)
  (setq mode-name   "Help"
        major-mode  'help-mode)
  (make-local-variable 'font-lock-defaults)
  (setq font-lock-defaults  nil)        ; font-lock would defeat xref
  (view-mode)
  (make-local-variable 'view-no-disable-on-exit)
  (setq view-no-disable-on-exit  t
        view-exit-action         (lambda (buffer)
                                   (or (window-minibuffer-p (selected-window))
                                       (when (eq (window-buffer) (get-buffer "*Help*"))
                                         (if (one-window-p t)
                                             (delete-frame)
                                           (delete-window))))))
  ;; `help-make-xrefs' would be run here if not invoked from
  ;; `help-mode-maybe'.
  (run-hooks 'help-mode-hook))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages added.
;;;###autoload
(defun help-with-tutorial (&optional arg)
  "Select the Emacs learn-by-doing tutorial.
If there is a tutorial version written in the language
of the selected language environment, that version is used.
If there's no tutorial in that language, `TUTORIAL' is selected.
With prefix ARG, you are asked to choose which language."
  (interactive "P")
  (message "Looking for Emacs Tutorial file...")
  (let ((lang  (if arg
                   (read-language-name 'tutorial "Language: " "English")
                 (if (get-language-info current-language-environment 'tutorial)
                     current-language-environment
                   "English")))
        file filename)
    (setq filename  (get-language-info lang 'tutorial)
          file      (expand-file-name (concat "~/" filename)))
    (delete-other-windows)
    (if (get-file-buffer file)
        (switch-to-buffer-other-window (get-file-buffer file))
      (switch-to-buffer-other-window (create-file-buffer file))
      (setq buffer-file-name            file
            default-directory           (expand-file-name "~/")
            buffer-auto-save-file-name  nil)
      (insert-file-contents (expand-file-name filename data-directory))
      (goto-char (point-min))
      (search-forward "\n<<")
      (beginning-of-line)
      (delete-region (point) (line-end-position))
      (let ((n  (- (window-height (selected-window))
                   (count-lines (point-min) (point))
                   6)))
        (if (< n 12)
            (newline n)
          ;; Some people get confused by the large gap.
          (newline (/ n 2))
          (insert "[Middle of page left blank for didactic purposes.  "
                  "Text continues below]")
          (newline (- n (/ n 2)))))
      (goto-char (point-min))
      (set-buffer-modified-p nil)))
  (remove-help-window)
  (message "Looking for Emacs Tutorial file...done"))


;; REPLACES ORIGINAL in `help.el':
;; Return nil if KEY is undefined; else return t.
;;
;;;###autoload
(defun describe-key (key)
  "Describe the command that a keyboard/menu/mouse sequence invokes.
Argument KEY is a string.
Return nil if KEY is undefined; else return t."
  (interactive "kDescribe command bound to keyboard/menu/mouse sequence: ")
  (save-excursion
    (let ((modifiers  (event-modifiers (aref key 0)))
          window position)
      ;; For a mouse button event, go to the button it applies to
      ;; to get the right key bindings.  And go to the right place
      ;; in case the keymap depends on where you clicked.
      (if (or (memq 'click modifiers) (memq 'down modifiers)
              (memq 'drag modifiers))
          (setq window    (posn-window (event-start (aref key 0)))
                position  (posn-point (event-start (aref key 0)))))
      (if (windowp window)
          (progn
            (set-buffer (window-buffer window))
            (goto-char position)))
      (let ((defn  (key-binding key)))
        (cond ((or (null defn) (integerp defn))
               (message "`%s' is undefined." (if (fboundp 'naked-key-description)
                                                 (naked-key-description key)
                                               (key-description key)))
               nil)                     ; Return nil: undefined.
              (t
               (with-output-to-temp-buffer "*Help*"
                 (princ (if (fboundp 'naked-key-description)
                            (naked-key-description key)
                          (key-description key)))
                 (if (windowp window)
                     (princ " at that spot"))
                 (princ " runs the command ")
                 (prin1 defn)
                 (princ "\n   which is ")
                 (describe-function-1 defn nil (interactive-p))
                 (print-help-return-message))
               t))))))                  ; Return t: defined.


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages.
;;
;;;###autoload
(defun describe-project ()
  "Display information on the GNU project."
  (interactive)
  (message "Looking for file describing GNU project...")
  (find-file-read-only-other-window (expand-file-name "GNU" data-directory))
  (remove-help-window)
  (message "Looking for file describing GNU project...done"))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Messages added.
;; 4. Turns off `auto-save-mode'.
;;
;;;###autoload
(defun view-emacs-news (&optional arg)
  "Display information on recent changes to Emacs.
With numeric prefix ARG, display correspondingly older changes."
  (interactive "P")
  (message "Looking for Emacs Changes file...")
  (let ((arg  (if arg (prefix-numeric-value arg) 0)))
    (find-file-read-only-other-window
     (expand-file-name (concat (make-string arg ?O) "NEWS")
                       data-directory)))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs Changes file...done"))


;; REPLACES ORIGINAL in `help.el':
;; 1. Uses other window.
;; 2. Calls `remove-help-window'.
;; 3. Turns off `auto-save-mode'.
;;
;;;###autoload
(defun view-emacs-FAQ ()
  "Display Frequently Asked Questions about Emacs (with answers)."
  (interactive)
  (message "Looking for Emacs FAQ file...")
  (find-file-read-only-other-window (expand-file-name "FAQ" data-directory))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs FAQ file...done"))


;; REPLACES ORIGINAL in `help.el':
;; Updated key bindings.
;;
(make-help-screen help-for-help
  "RET [abcCfFhiIklLmnopqstuvw] C-[\acdfiklnopsw] M-[acko] C-M-a (? for more help):"
  "This is the Emacs `help-command', accessible via `%THIS-KEY%'.
Type a Help option (below) now, for help on a particular topic.
Use \\<help-map>`\\[scroll-up]' or `\\[scroll-down]' to scroll this text.  \
Type `\\[help-quit]' to exit Help.
\(A \"command\" is any function that you can execute via `M-x'.)

LEARNING EMACS
--------------
\\[help-with-tutorial]:   Starts a tutorial for learning Emacs.
\\[view-emacs-FAQ]:   Explains frequently asked Emacs questions.

COMMONLY USED
-------------
\\[help-on-click/key]: Help about a key sequence or something you click with the mouse.
\\[apropos-command]:   Shows commands that match a regular expression (regexp).
\\[describe-bindings]:   Shows current key bindings: keyboard, menu bar, and mouse.
\\[describe-command]:   Shows the doc for an Emacs command.
\\[describe-function]:   Shows the doc for an Emacs function.
\\[info]:   Enters `Info', to browse manuals, including Emacs and Emacs Lisp.
\\[describe-key]:   Describes the command bound to keyboard/menu/mouse sequence.
\\[describe-mode]:   Describes the current major and minor modes.
\\[describe-option]:   Shows an Emacs user option's value and documentation.
\\[describe-variable]:   Shows an Emacs variable's value and documentation.
\\[Info-goto-emacs-command-node]: Opens the Emacs manual for an Emacs command.
\\[Info-goto-emacs-key-command-node]: Opens the Emacs manual for a keyboard/menu/mouse \
sequence.

MORE ADVANCED HELP
------------------
\\[view-lossage]:   Shows what you just typed (last 100 keystrokes & mouse actions).
\\[view-emacs-news]:   Describes what's new in this Emacs release.
\\[finder-by-keyword]:   Finds Emacs-Lisp libraries that match a topic.
\\[describe-syntax]:   Describes the current syntax table.
\\[manual-entry]:   Finds a topic in the Unix manual.
\\[where-is]:   Identifies a keyboard/menu/mouse sequence that invokes a command.
\\[apropos]: Shows Emacs functions and variables that match a regexp.
\\[describe-key-briefly]: Identifies the command bound to a keyboard/menu/mouse sequence.
\\[describe-distribution]: Shows Emacs ordering information.
\\[locate-library]: Shows the path name to an Emacs library.
\\[view-emacs-lisp-news]: Describes latest Emacs Lisp changes.
\\[describe-project]: Shows information about the GNU project.
\\[save-*Help*-buffer]: Renames buffer *Help* as buffer *Help*<N>.
\\[describe-no-warranty]: Shows information about the absence of a warranty.
\\[apropos-documentation]: Shows Emacs functions and variables whose doc matches a regexp.
\\[describe-copying]: Shows the GNU Emacs General Public License.
\\[pop-to-help-toggle]: Pops to Help buffer or back to the buffer that sent you to Help.
\\[tags-apropos]: Shows the tags matched by a given string.

INTERNATIONAL
-------------
\\[describe-coding-system]:   Describes a coding system.
h    Displays the HELLO file, which illustrates scripts and languages.
\\[describe-input-method]:   Describes an input method.
\\[describe-language-environment]:   Describes a language environment.
\\[info-lookup-symbol]: Finds a symbol in the manual for the current buffer's language.
"
  help-map)


(or (fboundp 'old-describe-mode)
    (fset 'old-describe-mode (symbol-function 'describe-mode)))


;; REPLACES ORIGINAL in `help.el':
;; 1. Provides message telling how to change pages in *Help* buffer.
;; 2. Doc string also explains this.
;;    Really, the text at the beginning of *Help* should explain this - TO BE DONE.
;;
;;;###autoload
(defun describe-mode ()
  "Display documentation of current major mode and minor modes.
Each mode (minor or major) is displayed on a different \"page\" in the
*Help* buffer (the pages are separated by `^L' characters).
You can change pages with `\\[forward-page]' and `\\[backward-page]'.

Note: For a minor mode to be described correctly here, the mode's
indicator variable (listed in `minor-mode-alist') must also be a
function whose documentation describes the minor mode."
  (interactive)
  (let ((font-lock-verbose  nil))       ; This should inhibit msgs, but doesn't!
    (old-describe-mode)
    (message (substitute-command-keys
              "You can use `\\[forward-page]' and `\\[backward-page]' \
in *Help* buffer to change pages."))))


;; REPLACES ORIGINAL in `help.el':
;; Preferred candidate is `symbol-nearest-point'.
;; With a prefix argument, candidates are commands only.
;;
;;;###autoload
(defun describe-function (function &optional commandp)
  "Display the full documentation of FUNCTION (a symbol).
FUNCTION names an Emacs Lisp function, possibly a user command.
With a prefix argument, candidates are commands (interactive) only.
Default candidate is: preferably the `symbol-nearest-point', or else
the innermost function call surrounding point
\(`function-called-at-point').
Return the description that was displayed, as a string."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read
                    (if current-prefix-arg "Describe command: " "Describe function: ")
                    obarray (if current-prefix-arg 'commandp 'fboundp) t nil nil
                    (and fn (symbol-name fn)) t))
           current-prefix-arg)))
  (unless (or (not commandp) (commandp function))
    (error "Not a defined Emacs command (interactive function): `%s'" function))
  (unless (fboundp function)
    (error "Not a defined Emacs function: `%s'" function))
  (with-output-to-temp-buffer "*Help*"
    (prin1 function)
    ;; Use " is " instead of a colon so that
    ;; it is easier to get out the function name using forward-sexp.
    (princ " is ")
    (describe-function-1 function nil (interactive-p))
    (print-help-return-message)
    (save-excursion
      (set-buffer standard-output)
      ;; Return the text we displayed.
      (buffer-string))))


;; REPLACES ORIGINAL in `help.el':
;;
;; Ignore symbols that produce errors.  Example: In Emacs 20, `any', which is defalias'd
;; to `icicle-anything', raises this error: "Symbol's function definition is void: any".
;; This is caused by the `after' advice `ad-advised-docstring' that is defined by Emacs
;; itself for function `documentation'.  It is not a problem for Emacs 22+.
;;
;;;###autoload
(defun describe-function-1 (function parens interactive-p)
  (let* ((def (if (symbolp function)
          (symbol-function function)
        function))
     file-name string need-close
     (beg (if (commandp def) "an interactive " "a ")))
    (setq string
      (cond ((or (stringp def)
             (vectorp def))
         "a keyboard macro")
        ((subrp def)
         (concat beg "built-in function"))
        ((byte-code-function-p def)
         (concat beg "compiled Lisp function"))
        ((symbolp def)
         (while (symbolp (symbol-function def))
           (setq def (symbol-function def)))
         (format "an alias for `%s'" def))
        ((eq (car-safe def) 'lambda)
         (concat beg "Lisp function"))
        ((eq (car-safe def) 'macro)
         "a Lisp macro")
        ((eq (car-safe def) 'mocklisp)
         "a mocklisp function")
        ((eq (car-safe def) 'autoload)
         (setq file-name (nth 1 def))
         (format "%s autoloaded %s"
             (if (commandp def) "an interactive" "an")
             (if (eq (nth 4 def) 'keymap) "keymap"
               (if (nth 4 def) "Lisp macro" "Lisp function"))
             ))
        (t "")))
    (when (and parens (not (equal string "")))
      (setq need-close t)
      (princ "("))
    (princ string)
    (with-current-buffer "*Help*"
      (save-excursion
    (save-match-data
      (if (re-search-backward "alias for `\\([^`']+\\)'" nil t)
          (help-xref-button 1 #'describe-function def)))))
    (or file-name
    (setq file-name (symbol-file function)))
    (if file-name
    (progn
      (princ " in `")
      ;; We used to add .el to the file name,
      ;; but that's completely wrong when the user used load-file.
      (princ file-name)
      (princ "'")
      ;; Make a hyperlink to the library.
      (with-current-buffer "*Help*"
        (save-excursion
          (re-search-backward "`\\([^`']+\\)'" nil t)
          (help-xref-button 1 #'(lambda (arg)
                      (let ((location
                         (find-function-noselect arg)))
                    (pop-to-buffer (car location))
                    (goto-char (cdr location))))
                function)))))
    (if need-close (princ ")"))
    (princ ".")
    (terpri)
    ;; Handle symbols aliased to other symbols.
    (setq def (indirect-function def))
    ;; If definition is a macro, find the function inside it.
    (if (eq (car-safe def) 'macro)
    (setq def (cdr def)))
    (let ((arglist (cond ((byte-code-function-p def)
              (car (append def nil)))
             ((eq (car-safe def) 'lambda)
              (nth 1 def))
             (t t))))
      (if (listp arglist)
      (progn
        (princ (cons (if (symbolp function) function "anonymous")
             (mapcar (lambda (arg)
                   (if (memq arg '(&optional &rest))
                       arg
                     (intern (upcase (symbol-name arg)))))
                 arglist)))
        (terpri))))
    (let ((doc (condition-case nil (documentation function) (error nil))))
      (if doc
      (progn (terpri)
         (princ doc)
         (help-setup-xref (list #'describe-function function) interactive-p))
    (princ "not documented")))))

;;;###autoload
(defun describe-command (function)
  "Describe an Emacs command (interactive function).
Same as using a prefix arg with `describe-function'."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe command: " obarray 'commandp
                                    t nil nil (and fn (symbol-name fn)) t)))))
  (describe-function function t))


;; REPLACES ORIGINAL in `help.el':
;;
;; 1. Preferred candidate is `symbol-nearest-point'.
;; 2. Use `substitute-command-keys' on doc string.
;; 3. Remove initial `*' from doc string (indicates it is a user variable).
;; 4. With a prefix argument, candidates are user variables (options) only.
;;
;;;###autoload
(defun describe-variable (variable &optional optionp)
  "Display the full documentation of VARIABLE (a symbol).
VARIABLE names an Emacs Lisp variable, possibly a user option.
With a prefix argument, candidates are user variables (options) only.
Default candidate is the `symbol-nearest-point'.
Return the documentation, as a string."
  (interactive
   (let ((symb                          (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (and (symbolp (variable-at-point))
                                                 (variable-at-point))))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe variable: " obarray
                                    (if current-prefix-arg 'user-variable-p 'boundp)
                                    t nil nil (and symb (symbol-name symb)) t))
           current-prefix-arg)))
  (unless (or (not optionp) (or (user-variable-p variable) (custom-variable-p variable)))
    (error "Not a defined Emacs user option: `%s'" variable))
  (unless (boundp variable) (error "Not a defined Emacs variable: `%s'" variable))
  (let (valvoid)
    (with-output-to-temp-buffer "*Help*"
      (prin1 variable)
      (if (not (boundp variable))       ; This will never happen.
          (progn (princ " is void") (terpri) (setq valvoid  t))
        (princ "'s value is ")
        (terpri)
        (pp (symbol-value variable))
        (terpri))
      (when (local-variable-p variable)
        (princ (format "Local in buffer %s; " (buffer-name)))
        (if (not (default-boundp variable))
            (princ "globally void")
          (princ "global value is ")
          (terpri)
          (pp (default-value variable)))
        (terpri))
      (terpri)
      (save-current-buffer
        (set-buffer standard-output)
        (when (> (count-lines (point-min) (point-max)) 10)
          (goto-char (point-min))
          (if valvoid
              (forward-line 1)
            (forward-sexp 1)
            (delete-region (point) (line-end-position))
            (insert "'s value is shown below.\n\n")
            (save-excursion (insert "\n\nValue:")))))
      (princ "Documentation:")
      (terpri)
      (let ((doc  (documentation-property variable 'variable-documentation)))
        (if (or (null doc)  (string= "" doc))
            (princ "Not documented as a variable.")
          (when (and (> (length doc) 1)  (eq ?* (elt doc 0)))
            (setq doc  (substring doc 1))) ; Remove any user-variable prefix `*'.
          (princ (substitute-command-keys doc))))
      (help-setup-xref (list #'describe-variable variable) (interactive-p))
      ;; Make a link to customize if this variable can be customized.
      ;; Note, it is not reliable to test only for a custom-type property
      ;; because those are only present after the var's definition
      ;; has been loaded.
      (when (or (get variable 'custom-type) ; after defcustom
                (get variable 'custom-loads) ; from loaddefs.el
                (get variable 'standard-value)) ; from cus-start.el
        (let ((customize-label  "customize"))
          (terpri)
          (terpri)
          (princ (concat "You can " customize-label " this variable."))
          (with-current-buffer "*Help*"
            (save-excursion  (re-search-backward
                              (concat "\\(" customize-label "\\)") nil t)
                             (help-xref-button 1 #'(lambda (v)
                                                     (customize-variable v)) variable)))))
      ;; Make a hyperlink to the library if appropriate.  (Don't
      ;; change the format of the buffer's initial line in case
      ;; anything expects the current format.)
      (when (string< "20.5" emacs-version)
        (let ((file-name  (symbol-file variable)))
          (when file-name
            (princ "\n\nDefined in `")
            (princ file-name)
            (princ "'.")
            (with-current-buffer "*Help*"
              (save-excursion
                (re-search-backward "`\\([^`']+\\)'" nil t)
                (help-xref-button 1 (lambda (arg)
                                      (let ((location  (find-variable-noselect arg)))
                                        (pop-to-buffer (car location))
                                        (goto-char (cdr location))))
                                  variable))))))

      (print-help-return-message)
      (save-excursion (set-buffer standard-output)
                      (buffer-string))))) ; Return the text we displayed.

;;;###autoload
(defun describe-option (variable)
  "Describe an Emacs user variable (option).
Same as using a prefix arg with `describe-variable'."
  (interactive
   (let ((symb                          (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (and (symbolp (variable-at-point))
                                                 (variable-at-point))))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Describe user option: " obarray
                                    ;; Emacs 20 `user-variable-p' does not include defcustoms.
                                    (lambda (c) (or (custom-variable-p c) (user-variable-p c)))
                                    t nil nil (and symb (symbol-name symb)) t)))))
  (describe-variable variable t))

;;;###autoload
(defun describe-option-of-type (type option)
  "Describe an Emacs user OPTION (variable) of a given `defcustom' TYPE.
A prefix argument determines the type-checking behavior:
 - None:         OPTION is defined with TYPE or a subtype of TYPE.
 - Plain `C-u':  OPTION is defined with TYPE or a subtype of TYPE,
                 or its current value is compatible with TYPE.
 - Negative:     OPTION is defined with TYPE (exact match).
 - Non-negative: OPTION is defined with TYPE (exact match),
                 or its current value is compatible with TYPE.

If TYPE is nil (default value) then *all* `defcustom' variables are
potential candidates.  That is different from using `describe-option',
because `describe-option' includes user-variable candidates not
defined with `defcustom' (with `*'-prefixed doc strings)."
  (interactive
   (let* ((symb      (or (and (fboundp 'symbol-nearest-point) (symbol-nearest-point))
                         (and (symbolp (variable-at-point)) (variable-at-point))))
          (typ       (car (condition-case err
                              (read-from-string
                               (let ((types  ()))
                                 (mapatoms
                                  (lambda (cand)
                                    (when (if (fboundp 'custom-variable-p) ; Not in Emacs 20.
                                              (custom-variable-p cand)
                                            (user-variable-p cand))
                                      (push (list
                                             (format "%s" (format "%S" (get cand 'custom-type))))
                                            types))))
                                 (completing-read "Describe option of type: "
                                                  (help-remove-duplicates types)
                                                  nil nil nil nil "nil")))
                            (end-of-file (error "No such custom type")))))
          (pref-arg  current-prefix-arg))
     (list typ (intern (completing-read
                        "Option: " obarray
                        (lambda (v)
                          (and (if (fboundp 'custom-variable-p) ; Not in vanilla Emacs 20.
                                   (custom-variable-p v)
                                 (user-variable-p v))
                               (or (not typ) ; Allow all vars if requested type = nil.
                                   (help-var-is-of-type-p
                                    v (list typ)
                                    (cond ((not pref-arg) 'inherit)
                                          ((consp pref-arg) 'inherit-or-value)
                                          ((wholenump (prefix-numeric-value pref-arg))
                                           'direct-or-value)
                                          (t 'direct))))))
                        t nil nil (and symb (symbol-name symb)) t)))))
  (describe-variable option t))

(defun help-var-is-of-type-p (variable types &optional mode)
  "Return non-nil if VARIABLE satisfies one of the custom types in TYPES.
TYPES is a list of `defcustom' type sexps or a list of regexp strings.
TYPES are matched, in order, against VARIABLE's type definition or
VARIABLE's current value, until one is satisfied or all are tried.

If TYPES is a list of regexps, then each is regexp-matched against
VARIABLE's custom type.

Otherwise, TYPES is a list of type sexps, each of which is a
definition acceptable for `defcustom' :type or the first symbol of
such a definition (e.g. `choice').  In this case, two kinds of type
comparison are possible:

1. VARIABLE's custom type, or its first symbol, is matched using
  `equal' against each type in TYPES.

2. VARIABLE's current value is checked against each type in TYPES to
   see if it satisfies one of them.  In this case, VARIABLE's own type
   is not used; VARIABLE might not even be typed - it could be a
   variable not defined using `defcustom'.

For any of the comparisons against VARIABLE's type, either that type
can be checked directly or its supertypes (inherited types) can also
be checked.

These different type-checking possibilities depend on the value of
argument MODE, as follows, and they determine the meaning of the
returned value:

`direct':   VARIABLE's type matches a member of list TYPES
`inherit':  VARIABLE's type matches or is a subtype of a TYPES member
`value':    VARIABLE is bound, and its value satisfies a type in TYPES
`inherit-or-value': `inherit' or `value', tested in that order
`direct-or-value':  `direct' or `value', tested in that order
anything else (default): `inherit'

VARIABLE's current value cannot satisfy a regexp type: it is
impossible to know which concrete types a value must match."
  (case mode
    ((nil inherit)     (help-var-inherits-type-p variable types))
    (inherit-or-value  (or (help-var-inherits-type-p variable types)
                           (help-var-val-satisfies-type-p variable types)))
    (value             (help-var-val-satisfies-type-p variable types))
    (direct            (help-var-matches-type-p variable types))
    (direct-or-value   (or (member (get variable 'custom-type) types)
                           (help-var-val-satisfies-type-p variable types)))
    (otherwise         (help-var-inherits-type-p variable types))))

(defun help-var-matches-type-p (variable types)
  "VARIABLE's type matches a member of TYPES."
  (catch 'help-type-matches
    (let ((var-type  (get variable 'custom-type)))
      (dolist (type  types)
        (when (if (stringp type)
                  (save-match-data (string-match type (format "%s" (format "%S" var-type))))
                (equal var-type type))
          (throw 'help-type-matches t))))
    nil))

(defun help-var-inherits-type-p (variable types)
  "VARIABLE's type matches or is a subtype of a member of list TYPES."
  (catch 'help-type-inherits
    (let ((var-type  (get variable 'custom-type)))
      (dolist (type  types)
        (while var-type
          (when (or (and (stringp type)
                         (save-match-data
                           (string-match type (format "%s" (format "%S" var-type)))))
                    (equal type var-type))
            (throw 'help-type-inherits t))
          (when (consp var-type) (setq var-type  (car var-type)))
          (when (or (and (stringp type)
                         (save-match-data
                           (string-match type (format "%s" (format "%S" var-type)))))
                    (equal type var-type))
            (throw 'help-type-inherits t))
          (setq var-type  (car (get var-type 'widget-type))))
        (setq var-type  (get variable 'custom-type))))
    nil))

(defun help-var-val-satisfies-type-p (variable types)
  "VARIABLE is bound, and its value satisfies a type in the list TYPES."
  (and (boundp variable)
       (let ((val  (symbol-value variable)))
         (and (widget-convert (get variable 'custom-type))
              (help-value-satisfies-type-p val types)))))

(defun help-value-satisfies-type-p (value types)
  "Return non-nil if VALUE satisfies a type in the list TYPES."
  (catch 'help-type-value-satisfies
    (dolist (type  types)
      (unless (stringp type)            ; Skip, for regexp type.
        (setq type  (widget-convert type))
        ;; Satisfies if either :match or :validate.
        (when (condition-case nil
                  (progn (when (and (widget-get type :match)
                                    (widget-apply type :match value))
                           (throw 'help-type-value-satisfies t))
                         (when (and (widget-get type :validate)
                                    (progn (widget-put type :value value)
                                           (not (widget-apply type :validate))))
                           (throw 'help-type-value-satisfies t)))
                (error nil))
          (throw 'help-type-value-satisfies t))))
    nil))

(defun help-custom-type (variable)
  "Returns the `defcustom' type of VARIABLE.
Returns nil if VARIABLE is not a user option.

Note: If the library that defines VARIABLE has not yet been loaded,
then `help-custom-type' loads it.  Be sure you want to do that
before you call this function."
  (and (custom-variable-p variable)
       (or (get variable 'custom-type) (progn (custom-load-symbol variable)
                                              (get variable 'custom-type)))))

;; Borrowed from `ps-print.el'
(defun help-remove-duplicates (list)
  "Copy of LIST with duplicate elements removed.  Tested with `equal'."
  (let ((tail  list)
        new)
    (while tail
      (unless (member (car tail) new) (push (car tail) new))
      (pop tail))
    (nreverse new)))

;;;###autoload
(defun describe-file (filename &optional internal-form-p no-error-p)
  "Describe the file named FILENAME.
If FILENAME is nil, describe current directory (`default-directory').
If FILENAME is the name of an autofile bookmark and you use library
`Bookmark+', then show also the bookmark information (tags etc.).  In
this case, a prefix arg shows the internal form of the bookmark.

In Lisp code:

Non-nil optional arg INTERNAL-FORM-P shows the internal form.
Non-nil optional arg NO-ERROR-P prints an error message but does not
 raise an error."
  (interactive "FDescribe file: \nP")
  (unless filename (setq filename default-directory))
  (help-setup-xref `(describe-file ,filename ,internal-form-p ,no-error-p) (interactive-p))
  (let ((attrs  (file-attributes filename))
        ;; Functions `bmkp-*' are defined in `bookmark+.el'.
        (bmk   (and (fboundp 'bmkp-get-autofile-bookmark)  (bmkp-get-autofile-bookmark filename))))
    (if (not attrs)
        (if no-error-p
            (message "Cannot open file `%s'" filename)
          (error "Cannot open file `%s'" filename))
      (let* ((type             (nth 0 attrs))
             (numlinks         (nth 1 attrs))
             (uid              (nth 2 attrs))
             (gid              (nth 3 attrs))
             (last-access      (nth 4 attrs))
             (last-mod         (nth 5 attrs))
             (last-status-chg  (nth 6 attrs))
             (size             (nth 7 attrs))
             (permissions      (nth 8 attrs))
             ;; Skip 9: t iff file's gid would change if file were deleted and recreated.
             (inode            (nth 10 attrs))
             (device           (nth 11 attrs))
             (help-text
              (concat
               (format "`%s'\n%s\n\n" filename (make-string (+ 2 (length filename)) ?-))
               (format "File Type:                       %s\n"
                       (cond ((eq t type) "Directory")
                             ((stringp type) (format "Symbolic link to `%s'" type))
                             (t "Normal file")))
               (format "Permissions:                %s\n" permissions)
               (and (not (eq t type)) (format "Size in bytes:              %g\n" size))
               (format-time-string
                "Time of last access:        %a %b %e %T %Y (%Z)\n" last-access)
               (format-time-string
                "Time of last modification:  %a %b %e %T %Y (%Z)\n" last-mod)
               (format-time-string
                "Time of last status change: %a %b %e %T %Y (%Z)\n" last-status-chg)
               (format "Number of links:            %d\n" numlinks)
               (format "User ID (UID):              %s\n" uid)
               (format "Group ID (GID):             %s\n" gid)
               (format "Inode:                      %S\n" inode)
               (format "Device number:              %s\n" device))))
        (with-output-to-temp-buffer "*Help*"
          (when bmk
            (if internal-form-p
                (let* ((bname     (bookmark-name-from-full-record bmk))
                       (bmk-defn  (format "Bookmark `%s'\n%s\n\n%s"
                                          bname   (make-string (+ 11 (length bname)) ?-)
                                          (pp-to-string bmk))))
                  (princ bmk-defn) (terpri) (terpri))
              (princ (bmkp-bookmark-description bmk 'NO-IMAGE)) (terpri) (terpri)))
          (princ help-text))
        help-text))))                   ; Return displayed text.

;;;###autoload
(defun describe-keymap (keymap)
  "Describe bindings in KEYMAP, a variable whose value is a keymap.
Completion is available for the keymap name."
  (interactive
   (list (intern
          (completing-read
           "Keymap: " obarray
           (lambda (m) (and (boundp m) (keymapp (symbol-value m))))
           t nil 'variable-name-history))))
  (unless (and (symbolp keymap) (boundp keymap) (keymapp (symbol-value keymap)))
    (error "`%S' is not a keymapp" keymap))
  (let ((name  (symbol-name keymap))
        (doc   (documentation-property keymap 'variable-documentation)))
    (help-setup-xref (list #'describe-keymap keymap) (interactive-p))
    (with-output-to-temp-buffer "*Help*"
      (princ name) (terpri)
      (princ (make-string (length name) ?-)) (terpri) (terpri)
      (when doc (princ doc) (terpri) (terpri))
      ;; Use `insert' instead of `princ', so control chars (e.g. \377) insert correctly.
      (with-current-buffer "*Help*"
        (insert (substitute-command-keys (concat "\\{" name "}")))))))


;; REPLACES ORIGINAL in `help.el':
;; 1. Preferred candidate is `symbol-nearest-point'.
;; 2. Must be a command, not just a function.
;; 3. Calls `remove-help-window'.
;;
;;;###autoload
(defun where-is (definition &optional insert)
  "Give keyboard/menu/mouse sequences that invoke specified command.
Argument DEFINITION is a command definition, usually a symbol with a
function definition.  Default candidate is: preferably the
`symbol-nearest-point', or else the innermost function call
surrounding point (`function-called-at-point').
Non-nil prefix arg INSERT means insert the message in the buffer."
  (interactive
   (let ((fn                            (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (function-called-at-point)))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read "Where is command: " obarray 'commandp t
                                    nil nil (and fn (symbol-name fn)) t)))))
  (remove-help-window)
  (let* ((keys             (where-is-internal definition overriding-local-map nil nil))
         (keys1            (mapconcat (if (fboundp 'naked-key-description)
                                          #'naked-key-description
                                        #'key-description)
                                      keys ", "))
         (standard-output  (if insert (current-buffer) t)))
    (if insert
        (if (> (length keys1) 0)
            (princ (format "%s (%s)" keys1 definition))
          (princ (format "M-x %s RET" definition)))
      (if (> (length keys1) 0)
          (princ (format "`%s' is on `%s'" definition keys1))
        (princ (format "`%s' is not on any key" definition)))))
  nil)


;; REPLACES ORIGINAL in `help.el':
;; Lets you complete the library name against string variables.
;; Calls `remove-help-window'.
;;
;;;###autoload
(defun locate-library (library &optional nosuffix path interactive-call)
  "Show the full path name of Emacs library LIBRARY.
This command searches the directories in your `load-path' like
`M-x load-library' to find the file that would be loaded by
`M-x load-library RET LIBRARY RET'.

Optional second arg NOSUFFIX non-nil means don't add suffixes `.elc'
or `.el' to the specified name LIBRARY (like calling `load' instead of
`load-library').

If the optional third arg PATH is specified, that list of directories
is used instead of `load-path'.

When called from a program, the file name is normally returned as a
string.  When run interactively, the argument INTERACTIVE-CALL is t,
and the file name is displayed in the echo area."
  (interactive (list (if (fboundp 'icicle-read-string-completing)
                         (icicle-read-string-completing "Locate library: ")
                       (read-string "Locate library: "))
                     nil nil t))
  (let (result)
    (catch 'answer
      (mapcar
       (lambda (dir)
         (mapcar (lambda (suf)
                   (let ((try  (expand-file-name (concat library suf) dir)))
                     (when (and (file-readable-p try)
                                (null (file-directory-p try)))
                       (setq result  try)
                       (message "Library is file `%s'." try)
                       (throw 'answer try))))

                 (if nosuffix
                     '("")
                   '(".elc" ".el" "")
;;; load doesn't handle this yet.
;;;         (let ((basic  '(".elc" ".el" ""))
;;;               (compressed '(".Z" ".gz" "")))
;;;           ;; If autocompression mode is on,
;;;           ;; consider all combinations of library suffixes
;;;           ;; and compression suffixes.
;;;           (if (rassq 'jka-compr-handler file-name-handler-alist)
;;;               (apply 'nconc
;;;                      (mapcar (lambda (compelt)
;;;                                (mapcar (lambda (baselt)
;;;                                          (concat baselt compelt))
;;;                                        basic))
;;;                              compressed))
;;;             basic))
                   )))
       (or path load-path)))
    (and interactive-call
         (if result
             (message "Library is file `%s'" result)
           (message "No library `%s' in search path." library)))
    (remove-help-window)
    result))

;;;###autoload
(defun view-emacs-lisp-news ()
  "Display information on recent changes to Emacs Lisp."
  (interactive)
  (message "Looking for Emacs Lisp Changes file...")
  (find-file-read-only-other-window (expand-file-name "LNEWS" data-directory))
  (auto-save-mode nil)                  ; Turn it off.
  (remove-help-window)
  (message "Looking for Emacs Lisp Changes file...done"))

;;;###autoload
(defun save-*Help*-buffer ()
  "Rename *Help* buffer as new buffer *Help*<N>, N=2,3...."
  (interactive)
  (let ((notifying-user-of-mode  nil)    ; No msg on mode (in `misc-fns.el').
        (saved-help              (buffer-name (generate-new-buffer "*Help*"))))
    (save-excursion
      (set-buffer "*Help*")
      (copy-to-buffer saved-help (point-min) (point-max))
      (when (interactive-p)
        (message "Saved contents of *Help* buffer to buffer %s."
                 saved-help)))))

(defun help-on-click/key-lookup (key &optional pp-key where)
  "Look up information on KEY via `describe-key' and `info'.
Optional args PP-KEY and WHERE are strings naming KEY and its type.
Their defaults are KEY's `key-description' and \"Key sequence\".
Function `Info-goto-emacs-key-command-node' is used to look up KEY."
  (sit-for 0 200);; HACK to fix bug if click on scroll bar in `help-on-click/key'.
  (setq where   (or where "Key sequence ")
        pp-key  (or pp-key (if (fboundp 'naked-key-description)
                               (naked-key-description key)
                             (key-description key))))
  (let* ((described-p  (if (fboundp 'naked-key-description)
                           (naked-key-description key)
                         (key-description key)))
         ;; The version of `Info-goto-emacs-key-command-node' defined in `info+20.el' returns
         ;; non-nil if Info doc is found.  The standard version defined `info.el' will not.
         (documented-p (Info-goto-emacs-key-command-node key))) ; nil if have only std version
    (when (and (not documented-p)(get-buffer-window "*info*" 'visible)) (Info-exit))
    (cond ((and described-p documented-p)
           (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
           (message "%s`%s': summary in *Help* buffer; doc in *info* buffer."
                    where pp-key))
          (described-p
           (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
           (message "%s`%s': summary in *Help* buffer." where pp-key))
          (documented-p
           (message "%s`%s': doc in *info* buffer." where pp-key))
          (t
           (message "%s`%s' is undefined." where pp-key)))))

;;;###autoload
(defun help-on-click/key (key)
  "Give help on a key/menu sequence or object clicked with the mouse.
The object can be any part of an Emacs window or a name appearing in a
buffer.  You can do any of the following:

    type a key sequence (e.g. `C-M-s')
    choose a menu item (e.g. [menu-bar files open-file])
    click on a scroll bar
    click on the mode line
    click in the minibuffer
    click on an Emacs-related name in a buffer: apropos is called
    click anywhere else in a buffer: its modes are described

Help is generally provided using `describe-key' and the Emacs online
manual (via `Info-goto-emacs-key-command-node').  If no entry is found
in the index of the Emacs manual, then the manual is searched from the
beginning for literal occurrences of KEY.

For example, the KEY `C-g' is not in the index (for some reason), so
the manual is searched.  (Once an occurrence is found, you can
repeatedly type `s' in *Info* to search for additional occurrences.)

If you click on a name in a buffer, then `apropos-documentation' and
`apropos' are used to find information on the name.  These functions
are not used when you do something besides click on a name.

If you click elsewhere in a buffer other than the minibuffer, then
`describe-mode' is used to describe the buffer's current mode(s)."
  (interactive "kClick mouse on something or type a key sequence.")
  (let ((temp-buffer-show-function  'switch-to-buffer-other-window)
        (font-lock-verbose          nil)
        (global-font-lock-mode      nil))
    ;; DEBUG (message "KEY: `%s'" key)(sit-for 4) ; DEBUG
    (cond ((stringp key)
           (help-on-click/key-lookup key))
          (t                            ; Vector.
           (let ((type  (aref key 0)))
             (cond ((or (symbolp type)(integerp type))
                    (cond ((eq 'mode-line type) ; Click on the mode line.
                           (Info-goto-node "(emacs)Mode Line")
                           (message "Mode line: decribed in *info* buffer."))
                          (t            ; Normal key sequence.
                           (help-on-click/key-lookup key))))
                   ((eq 'menu-bar (car type))

                    (help-on-click/key-lookup key (aref key (1- (length key))) "Menu item "))
                   ((not (eq 'down (car (event-modifiers (car type))))) ; e.g. mouse menus
                    (help-on-click/key-lookup key))
                   (t                   ; Mouse click.
                    (setq key  type)
                    (cond ((window-minibuffer-p ; Click in minibuffer.
                            (posn-window (event-start key)))
                           (Info-goto-node "(emacs)Minibuffer")
                           (message "Minibuffer: decribed in *info* buffer."))
                          (t
                           (let ((symb            (save-excursion
                                                    (mouse-set-point key)
                                                    (if (fboundp 'tap-symbol-at-point)
                                                        (tap-symbol-at-point)
                                                      (symbol-at-point))))
                                 (apropos-do-all  t)
                                 (found-doc       nil)
                                 (found           nil)
                                 (symb-regexp     nil))
                             (cond (symb
                                    (message "Looking for info apropos `%s'..." symb)
                                    (when (get-buffer "*Apropos Doc*")
                                      (kill-buffer (get-buffer "*Apropos Doc*")))
                                    (setq found-doc  (apropos-documentation
                                                      (setq symb-regexp
                                                            (regexp-quote
                                                             (setq symb  (format "%s" symb))))))
                                    (when found-doc
                                      (save-excursion
                                        (set-buffer (get-buffer "*Apropos*"))
                                        (rename-buffer "*Apropos Doc*"))
                                      (when (fboundp '1-window-frames-on) ; In `frame-fns.el'.
                                        (let ((frames  (1-window-frames-on "*Apropos Doc*")))
                                          (while frames
                                            (save-window-excursion
                                              (select-frame (car frames))
                                              (rename-frame nil "*Apropos Doc*")
                                              (pop frames))))))
                                    (setq found  (apropos symb-regexp))
                                    ;; Remove empty stuff.
                                    (setq found  (and (consp found) (or (cdr found) (cadr found))))
                                    ;; Remove *Apropos* window that was displayed needlessly.
                                    (unless found (delete-windows-on "*Apropos*"))
                                    (cond
                                      ((and found-doc found)
                                       (message
                                        "See *Apropos* and *Apropos Doc* buffers."))
                                      (found
                                       (message
                                        "See information on `%s' in the *Apropos* buffer."
                                        symb))
                                      (found-doc
                                       (message
                                        "See information on `%s' in the *Apropos Doc* buffer."
                                        symb))
                                      (t
                                       (message
                                        "No information found regarding `%s'."
                                        symb))))
                                   (t   ; User clicked in buffer, but not on a symbol.
                                    (let ((bufname  (buffer-name (current-buffer))))
                                      (describe-mode)
                                      (when (fboundp 'show-*Help*-buffer) (show-*Help*-buffer))
                                      (message
                                       "Mode(s) of buffer `%s' are described in *Help* buffer."
                                       bufname))))))))))))))

;;;###autoload
(defun mouse-help-on-click (event)
  "Give help on an object clicked with the mouse."
  (interactive "e")
  (help-on-click/key (vector event)))

;;;###autoload
(defun mouse-help-on-mode-line-click (event)
  "Give help on the mode line."
  (interactive "e")
  (help-on-click/key (vector 'mode-line event)))

;;;###autoload
(defun pop-to-help-toggle ()
  "Pop to buffer *Help* or back to the buffer that sent you to *Help*."
  (interactive)
  (let ((orig-buf                   (and (buffer-live-p help-origin-buffer)
                                         (get-buffer help-origin-buffer)))
        (w32-grab-focus-on-raise    t)
        (win32-grab-focus-on-raise  t)) ; Older name.
    (if (string-match "*Help*" (buffer-name))
        (cond ((not orig-buf)
               (error "No buffer to return to"))
              ((string-match "Minibuf" (buffer-name orig-buf)) ; No `minibufferp' in Emacs 20.
               (select-frame-set-input-focus
                (window-frame (select-window (minibuffer-window)))))
              (t
               (pop-to-buffer orig-buf)))
      (setq help-origin-buffer  (current-buffer))
      (pop-to-buffer "*Help*"))))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'help+20)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; help+20.el ends here
#+end_src

** setup-keys.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; setup-keys.el --- Some key bindings.
;;
;; Filename: setup-keys.el
;; Description: Some key bindings.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1999-2021, Drew Adams, all rights reserved.
;; Created: Fri Apr  2 12:34:20 1999
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Feb  8 19:07:58 2021 (-0800)
;;           By: dradams
;;     Update #: 1361
;; URL: https://www.emacswiki.org/emacs/download/setup-keys.el
;; Keywords: mouse, keyboard, menus, menu-bar
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `apropos', `apropos+', `avoid', `backquote', `bookmark',
;;   `bookmark+', `bookmark+-1', `bookmark+-bmu', `bookmark+-key',
;;   `bookmark+-lit', `button', `bytecomp', `cconv', `cl', `cl-lib',
;;   `cmds-menu', `col-highlight', `color', `crosshairs', `cus-edit',
;;   `cus-face', `cus-load', `cus-start', `cus-theme', `custom',
;;   `doremi', `doremi-cmd', `doremi-frm', `easymenu', `faces',
;;   `faces+', `fit-frame', `font-lock', `font-lock+', `frame-cmds',
;;   `frame-fns', `gv', `help+', `help-fns', `help-fns+',
;;   `help-macro', `help-macro+', `help-mode', `hexrgb', `highlight',
;;   `highlight-symbol', `hl-line', `hl-line+', `info', `info+',
;;   `isearch+', `isearch-prop', `iso-transl', `kmacro', `macroexp',
;;   `menu-bar', `menu-bar+', `misc-cmds', `misc-fns', `mouse',
;;   `mouse+', `mwheel', `naked', `palette', `pp', `pp+',
;;   `radix-tree', `replace', `replace+', `ring', `second-sel',
;;   `strings', `syntax', `text-mode', `thingatpt', `thingatpt+',
;;   `timer', `vline', `w32browser-dlgopen', `wid-edit', `wid-edit+',
;;   `widget', `zones'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Some key bindings.
;;
;;  Think of this library more as an extension to your init file
;;  (~/.emacs) than as a true library.  It makes changes to your Emacs
;;  key bindings.  If you want only some of the bindings that are
;;  defined here, then either modify this file for your own use or
;;  load it and then modify selected bindings afterward.
;;
;;  The user options defined here are not customizable using Customize
;;  (they are not defined using `defcustom').  They are used only
;;  once, when this file is loaded - it makes no sense to change their
;;  values after this file is loaded.  To change their behavior from
;;  the default, set them in your init file before loading this
;;  library.
;;
;;  For example, if you do not want to substitute command
;;  `kill-buffer-and-its-windows' for command `kill-buffer' in all
;;  interactive uses, then put this in your init file *before* loading
;;  library `setup-keys':
;;
;;  (setq sub-kill-buffer-and-its-windows nil) ; Keep `kill-buffer'.
;;
;;  If you also load library `menu-bar+', then load it *before*
;;  loading library `setup-keys'.
;;
;;  User options defined here:
;;
;;    `sub-*-of-line', `sub-delete-windows-for',
;;    `sub-kill-buffer-and-its-windows', `sub-pp-evals',
;;    `sub-query-replace-w-options', `sub-quit-window-delete',
;;    `sub-recenter-top-bottom', `sub-transpose-sexps'.
;;
;;  Other variables defined here:
;;
;;    `comparison-map', `doremi-map'.
;;
;;  Functions defined here:
;;
;;    `remap-command'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2021/02/08 dadams
;;     Renamed to-indentation-repeat-(back|for)ward to (back|forward)-to-indentation+.
;; 2020/01/03 dadams
;;     Applied renamings from thing-cmd.el:
;;       mark-thing to select-things, cycle-thing-region to cycle-select-something.
;; 2018/11/09 dadams
;;     Change binding of to-indentation-repeat-backward to M-p.
;; 2018/09/22 dadams
;;     Use tear-off-window, not mouse-* (aliased), now in mouse+.el, not in frame-cmds.el.
;; 2018/09/14 dadams
;;     Added: sub-clone-frame.  Use it.
;; 2018/03/03 dadams
;;     Removed binding of <delete> to kill-line.
;; 2017/09/10 dadams
;;     Change binding of 1on1-fit-minibuffer-frame in minibuffer keymaps to M-up from C-o.
;; 2016/11/02 dadams
;;     Added: sub-transpose-sexps.
;;     Remap transpose-sexps to reversible-transpose-sexps, if sub-transpose-sexps.
;; 2016/09/18 dadams
;;     Applied renaming of secondary-dwim to secondary-yank|select|move|swap.
;; 2016/07/19 dadams
;;     Bound M-m to to-indentation-repeat-backward and M-n to to-indentation-repeat-forward.
;; 2016/01/24 dadams
;;     Bound C-x 5 1 to tear-off-window.
;; 2015/06/30 dadams
;;     Changed highlight-symbol-* bindings to f9 from f11.
;;     Replaced f12 by f8.
;; 2015/04/02 dadams
;;     Corrected command names for ni-narrow-to-*.
;; 2015/03/15 dadams
;;     Added: remap-command, sub-quit-window-delete.
;;     Remap quit-window to quit-window-delete, if sub-quit-window-delete.
;; 2014/11/28 dadams
;;     Bind compare-windows-repeat instead of compare-windows, if available.
;; 2014/10/29 dadams
;;     Bind (next|previous)-buffer-repeat.
;; 2014/05/23 dadams
;;     Bind narrow-indirect.el commands.
;; 2014/05/19 dadams
;;     If use mouse+.el then get rid of Emacs 24+ minibuffer.el's mouse-1 in echo area.
;;     Consolidate two eval-after-load's for mouse+.
;; 2014/03/12 dadams
;;     Bind C-M-^ to up-list, i.e., forward direction.
;; 2013/11/18 dadams
;;     Bind C-x C-; to comment-region-lines instead of comment-region.
;;     Do not require simple+.el.
;; 2013/11/07 dadams
;;     Bind hlt-highlight-enclosing-list to C-M-S.
;; 2013/10/23 dadams
;;     Bind C-x t s to either doremi-custom-themes+ or doremi-color-themes+.
;; 2013/09/15 dadams
;;     Do not bind help-on-click/key here.  Do not require help+(20).el for that.
;; 2013/09/01 dadams
;;     Added remapping of undo to undo-repeat.
;; 2013/08/23 dadams
;;     Soft-require highlight-symbol.el (Emacs 22+).  Bind its commands to f11 (+ modifiers).
;; 2013/07/25 dadams
;;     Invoke find-function-setup-keys.
;; 2013/07/05 dadams
;;     Bind move-frame-to-screen-top-left to C-S-home.
;; 2013/04/21 dadams
;;     Bind zoom-in/out to C-x +, C-x -, C-x =, C-x 0.
;; 2013/03/06 dadams
;;     Bind C-x C-M-SPC to set-secondary-start, C-x C-M-RET to secondary-save-then-kill.
;; 2013/01/17 dadams
;;     Added bindings for move-frame-to-screen-(top|bottom|left|right).
;; 2013/01/02 dadams
;;     Bound C-o also in minibuffer-(inactive-mode|local-(isearch|shell-command))-map.
;; 2012/12/24 dadams
;;     Added bindings for visual-line-mode line movements.
;; 2012/08/27 dadams
;;     Treat Emacs 24+ insert-char the same as ucs-insert (old name).
;; 2012/07/08 dadams
;;     Bind C-mouse-1 to ignore, so don't see error msg on up event.
;; 2012/07/02 dadams
;;     Bind find-library-other-window to C-x 4 l.
;; 2012/06/02 dadams
;;     If ucs-cmds.el is loaded, bind C-x 8 RET to ucsc-insert, if Emacs 23+.
;; 2011/11/12 dadams
;;     Vars sub-*: Removed (when (fboundp '*)...) wrapper - define always.  But mention in doc
;;       string that has no effect unless library loaded.
;; 2011/07/25 dadams
;;     Use eval-after-load where appropriate (e.g. instead of featurep/fboundp/boundp).
;; 2010/04/22 dadams
;;     Bound C-M-y to isearch-yank-secondary in isearch-mode-map.
;; 2010/02/24 dadams
;;     Bound C-; to iedit-mode, globally and in isearch-mode-map.
;; 2010/02/20 dadams
;;     Bound framemove keys: M-S-(up|down|left|right).
;; 2009/11/07 dadams
;;     Bound doremi-face-bg+ to k.  Applied doremi cmd renamings (added +).
;; 2009/08/26 dadams
;;     Changed binding of region-to-file from `C-x a' to C-x M-f, due to abbrev keys conflict.
;; 2009/07/26 dadams
;;     Fixed typo: prev-buffer -> previous-buffer.
;; 2009/06/25 dadams
;;     Use renaming: yank-secondary-or-swap-w-region to secondary-dwim.
;; 2009/06/11 dadams
;;     Bind zoom-(in|out), not zoom-frm-(in|out).
;;     Don't bind M-s if Emacs 23+.
;; 2009/05/17 dadams
;;     Updated to reflect thumb-frm.el name changes.
;; 2009/04/08 dadams
;;     Use revert-buffer-no-confirm, if defined.
;; 2009/04/06 dadams
;;     Changed binding of revert-buffer from S-f1 to f5 (a la MS Windows).
;; 2009/01/06 dadams
;;     Move delete-window from C-x C-a to C-x C-z, to avoid conflict with gud.
;;      Replaces std binding for iconify-or-deiconify-frame.
;; 2008/11/08 dadams
;;     Bind swiss-move-line-up/down to S-prior/S-next.
;; 2008/10/19 dadams
;;     Bind mouse-2 in ctl-x-map to ignore, so hlt-highlighter works on down-mouse-2.
;; 2008/08/17 dadams
;;     Made zoom-frm-(in|out) bindings portable, and make C- bindings work for Emacs 20, 21.
;; 2008/08/14 dadams
;;     Bound C-x C-a to delete-window, so you can do it with one hand.
;; 2008/08/07 dadams
;;     Bound zoom-frm-(in|out) to C-wheel-(down|up).
;; 2008/08/06 dadams
;;     Bind bm-toggle, bm-next, bm-previous to S-f3, C-f3, M-f3, not C-f3, f3, S-f3.
;; 2008/05/23 dadams
;;     Bound yank-pop-commands to M-y.  Soft-require second-sel.el.
;;     Soft-require second-sel.el.
;; 2008/05/06 dadams
;;     Renamed yank-secondary-or-convert-primary to yank-secondary-or-swap-w-region.
;; 2008/05/03 dadams
;;     Bind yank-secondary-or-convert-primary, not yank-secondary, to C-M-y.
;; 2008/03/19 dadams
;;     Don't bind C-o in completion maps if they inherit from minibuffer-local-map.
;; 2008/03/06 dadams
;;     Removed binding for iconify-everything - too easy to hit by mistake.
;; 2008/03/02 dadams
;;     Removed describe-file binding (done now in help-fns+.el and help+20.el).
;; 2007/12/14 dadams
;;     Require help+20.el for Emacs 20.  Require (new) help+.el for Emacss 22.
;; 2007/12/02 dadams
;;     Bound describe-face to C-h C-M-f.
;; 2007/11/21 dadams
;;     Bound C-o in minibuffer maps to 1on1-fit-minibuffer-frame.
;; 2007/11/06 dadams
;;     Added: sub-recenter-top-bottom.  Substituted recenter-top-bottom for recenter binding.
;; 2007/11/01 dadams
;;     Changed C-x t w from doremi-frame-width to doremi-window-height.
;; 2007/10/13 dadams
;;     Bound bm.el keys to [f3] with modifiers.
;; 2007/09/28 dadams
;;     Bound lisp-spell-symbol to M-#.
;; 2007/09/24 dadams
;;     Bound mark-buffer-(before|after)-point.
;; 2007/09/19 dadams
;;     Removed bindings for goto-previous(-global)-mark.
;; 2007/07/15 dadams
;;     Changed binding of cycle-thing-region to M-@.
;; 2007/06/04 dadams
;;     Removed sub-customize-other window (RMS's bug fix was implemented).
;; 2007/06/02 dadams
;;     Renamed: highlight to hlt-highlight,
;;              highlight-(highlighter|eraser) to hlt-(highlighter|eraser),
;;              highlight-(next|previous)-* to hlt-(next|previous)-*.
;; 2007/04/06 dadams
;;     Changed bindings of fisheye-(next|previous)-frame.
;; 2007/04/02 dadams
;;     Bound goto-longest-line to C-x L.
;; 2007/03/17 dadams
;;     Bound highlight-(next|previous)-highlight, highlight-eraser.
;; 2007/03/16 dadams
;;     Bound highlight-with-marker.  Protect with fboundp.
;; 2007/02/03 dadams
;;     Fixed mark-ring binding.  Thx to Fidel Salas.
;; 2007/01/27 dadams
;;     Bound S-down-mouse-2 to mouse-scan-lines-or-M-:, instead of mouse-M-:.
;; 2007/01/13 dadams
;;     Bound C-h M-f to describe-file.
;; 2006/11/04 dadams
;;     Bound S-down-mouse-2 to mouse-M-:.
;; 2006/11/03 dadams
;;     Bound down-mouse-2 to mouse-flash-position-or-M-x, not mouse-flash-position.
;; 2006/09/12 dadams
;;     Replaced [pause] by [f12] for C-x 8 synonym.  ([pause] is used by Icicles.)
;; 2006/09/08 dadams
;;     Bound crosshairs-mode to C-+.
;; 2006/08/22 dadams
;;     Replaced sub-remove-window by sub-delete-windows-for.
;; 2006/08/15 dadams
;;     Removed C-f1 binding of kill-buffer.
;; 2006/08/11 dadams
;;     Bound mouse-flash-position to down-mouse-2.
;; 2006/07/30 dadams
;;     Added bindings for mark-thing and cycle-thing-region.
;; 2006/05/26 dadams
;;     Clarified commentary.
;;     foldout-mouse-modifiers: Use setq, not defvar.
;; 2006/05/16 dadams
;;     Removed Icicles bindings - use new library icicles-keys.el instead.
;; 2006/03/01 dadams
;;     Bound icicle-complete-thesaurus-entry to C-c /.
;; 2006/01/24 dadams
;;     Bound icicle-execute-extended-command.
;; 2006/01/19 dadams
;;     Added sub-*-of-line.  Use it with move-*-of-line, if Emacs 22.
;; 2006/01/04 dadams
;;     Bound other-window-or-frame to C-x o.
;; 2005/12/13 dadams
;;     Bound delete-other-frames to C-x 4 1.
;; 2005/12/03 dadams
;;     Changed bindings of thumb-frm.el commands and show-hide.
;; 2005/11/18 dadams
;;     Bound mouse-4 to help-go-back in help-mode-map, and M-` to icicle-execute-menu-command.
;; 2005/10/27 dadams
;;     Renamed sub-icicle-buffer to sub-icicle-commands.  Bound icicle-find-file*.
;; 2005/10/16 dadams
;;     Bound icicle-compilation-search in compilation-minor-mode-map.  Bound grep in grep.
;; 2005/09/02 dadams
;;     Added sub-icicle-buffer, and substituted for switch-to-buffer*.
;;     Protected sub-* by fboundp.
;; 2005/08/13 dadams
;;     Added binding for icicle-execute-menu-command.
;; 2005/08/02 dadams
;;     Added binding for doremi-all-faces-fg.
;; 2005/05/29 dadams
;;     Added move-frame-* bindings.
;; 2005/05/17 dadams
;;     Updated to work with Emacs 22.x.
;; 2005/05/06 dadams
;;     Added commented-out binding for thumbify-frame-upon-event, as a model.
;; 2005/01/26 dadams
;;     Commented out (w32-register-hot-key [A-tab]).
;;     Removed ###autoload for defvars.
;; 2005/01/20 dadams
;;     Removed sub-exit-with-confirmation.
;; 2005/01/09 dadams
;;     Renamed: doremi-bg-rgb to doremi-bg, doremi-face-fg-rgb to doremi-face-fg.
;;     Changed some doremi bindings.
;; 2005/01/02 dadams
;;     Changed binding of region-to-file because `C-x w' conflicted with hi-lock.
;;     Added bindings for doremi-mark and doremi-global-mark; changed for doremi-bookmarks.
;; 2004/12/28 dadams
;;     Added doremi-face-fg-rgb binding.  Changed binding: doremi-font.
;; 2004/12/26 dadams
;;     Added thumb-frm.el bindings.
;; 2004/11/24 dadams
;;     (w32-register-hot-key [A-tab])
;; 2004/11/21 dadams
;;     Added [C-pause], [M-pause] bindings for prev-buffer, next-buffer.
;; 2004/11/20 dadams
;;     Refined to deal with Emacs 21 < 21.3.50 (soon to be 22.x)
;; 2004/11/16 dadams
;;     Added substitute-key-definition '*-of-line '*-of-line+.
;; 2004/10/13 dadams
;;     These were added for Emacs 21 also: replace+.el, buff-menu+.el.
;; 2004/10/02 dadams
;;     Per request by RMS:
;;     Renamed grow-frame-height and grow-frame-width to enlarge-frame
;;     and enlarge-frame-horizontally, respectively.
;;     Added shrink-frame and shrink-frame-horizontally.
;; 2004/09/21 dadams
;;     Don't require stuff that's not yet ready or inappropriate for Emacs 21.
;; 2004/09/11 dadams
;;     Bound vertical-line mouse commands.
;;     Added bindings for commands in doremi-frm.el.
;; 2004/08/26 dadams
;;     Changed C-M-up/down/left/right to enlarge-frame* and shrink-frame*.
;; 2004/04/28 dadams
;;     Added C-M-home and C-M-end bindings for beginning- and end-of-defun.
;; 1999/09/03 dadams
;;     Added sub-pp-evals.  Use it to replace eval-* with pp-eval-*.
;; 1999/09/02 dadams
;;     1. Added binding for show-hide.
;;     2. Added vars: sub-exit-with-confirmation,
;;        sub-kill-buffer-and-its-windows, sub-pp-evals,
;;        sub-query-replace-w-options, sub-remove-window.  Use to
;;        protect substitute-key-definition's.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'frame-cmds nil t) ;; (no error if not found): delete-other-frames,
                            ;; delete-windows-for, enlarge-frame*,
                            ;; iconify-everything, iconify/map-frame, move-frame-*,
                            ;; mouse-iconify/map-frame, mouse-remove-window,
                            ;; mouse-show-hide-mark-unmark, other-window-or-frame,
                            ;; show-*Help*-buffer, show-hide, shrink-frame*,
(require 'mouse+ nil t)     ;; (no error if not found):
                            ;; mouse-flash-position, (mouse-)tear-off-window
(require 'highlight nil t) ;; (no error if not found): hlt-highlight, hlt-highlighter,
                           ;; hlt-eraser, hlt-(next|previous)-highlight
(when (fboundp 'define-minor-mode) ;; (no error if not found): *-at-point,
  (require 'highlight-symbol nil t)) ;; *-(next|prev), *-query-replace

(require 'misc-cmds nil t) ;; (no error if not found): beginning-of-line+,
                           ;; end-of-line+, goto-longest-line, kill-buffer-and-its-windows,
                           ;; mark-buffer-after-point, mark-buffer-before-point,
                           ;; recenter-top-bottom, region-to-buffer, region-to-file,
                           ;; back-to-indentation+, forward-to-indentation+, undo-repeat
(require 'second-sel nil t) ;; (no error if not found): secondary-yank|select|move|swap,
                            ;; isearch-yank-secondary, yank-pop-commands,
                            ;; isearch-yank-secondary, set-secondary-start,
                            ;; secondary-save-then-kill
(require 'pp+ nil t) ;; (no error if not found): pp-eval-expression
(require 'fit-frame nil t) ;; (no error if not found):
                           ;; fit-frame, fit-frame-or-mouse-drag-vertical-line
(require 'doremi-frm nil t) ;; (no error if not found): doremi-bg+, doremi-face-fg+,
                            ;; doremi-font+, doremi-frame-font-size+, doremi-frame-configs+,
                            ;; doremi-frame-height+, doremi-frame-horizontally+,
                            ;; doremi-frame-vertically+
(require 'doremi-cmd nil t) ;; (no error if not found): doremi-buffers+, doremi-bookmarks+,
                            ;; doremi-color-themes+, doremi-custom-themes+

(when (< emacs-major-version 21)
  ;; (require 'help+20 nil t) ;; (no error if not found): help-on-click/key
  (require 'unaccent nil t)) ;; (no error if not found): unaccent-region, unaccent-word
;;; (when (> emacs-major-version 21)
;;;   (require 'help+ nil t)) ;; (no error if not found): help-on-click/key
(require 'replace+ nil t)   ;; (no error if not found): query-replace-w-options

;; Quiet the byte compiler.
(defvar grep-mode-map)                  ; Defined in `grep.el'.
(defvar mouse-wheel-down-event)         ; Defined in `mwheel.el'.
(defvar mouse-wheel-up-event)           ; Defined in `mwheel.el'.

;;;-----------------------------

(defun remap-command (old new map &optional oldmap)
  "Bind command NEW in MAP to all keys currently bound to OLD.
If command remapping is available, use that.  Otherwise, bind NEW to
whatever OLD is bound to in MAP, or in OLDMAP, if provided."
  (if (fboundp 'command-remapping)
      (define-key map (vector 'remap old) new) ; Ignore OLDMAP for Emacs 22.
    (substitute-key-definition old new map oldmap)))

(when (boundp 'help-mode-map) (define-key help-mode-map [mouse-4] 'help-go-back))
(when (boundp 'grep-mode-map) (define-key grep-mode-map "g" 'grep)) ; Emacs 22

(autoload 'compare-windows "compare-w"
  "Compare text in current window with text in next window." t)
(autoload 'ediff-buffers "ediff"
  "Run Ediff on a pair of buffers, BUFFER-A and BUFFER-B." t)
(autoload 'ediff-files "ediff"
  "Run Ediff on a pair of files, FILE-A and FILE-B." t)
(autoload 'kill-rectangle "rect"
  "Delete rectangle with corners at point & mark; save as last killed." t)
(autoload 'fill-individual-paragraphs "fill"
  "Fill paragraphs of uniform indentation within the region." t)
(autoload 'ispell-complete-word "ispell"
  "Complete word using letters at point to word beginning using `look'." t)
(autoload 'forward-whitespace "thingatpt" nil t)
(autoload 'forward-symbol "thingatpt" nil t)
(autoload 'dired-jump-other-window "dired-x"
  "Jump to dired buffer corresponding to current buffer, in new window." t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Don't let Windows grap ALT-TAB:
;; (when (eq system-type 'windows-nt) (w32-register-hot-key [A-tab]))

;; Additional definitions for some standard mouse commands:
;; SGI does not pass all ALT-mouse stuff thru to Emacs, so use C-M-mouse also:
(global-set-key [C-M-mouse-1] 'mouse-start-secondary) ; In `mouse.el'.            `C-M-mouse-1'
(global-set-key [C-M-drag-mouse-1] 'mouse-set-secondary) ; In `mouse.el'.
(global-set-key [C-M-down-mouse-1] 'mouse-drag-secondary) ; In `mouse.el'.
(global-set-key [C-M-mouse-3] 'mouse-secondary-save-then-kill) ; `second-sel.el'. `C-M-mouse-3'
(global-set-key [C-M-mouse-2] 'mouse-yank-secondary) ; `mouse+.el' or `mouse.el'  `C-M-mouse-2'

(global-set-key "\C-\M-^" 'up-list)                                              ; `C-M-^'

(eval-after-load "mouse+"
  '(progn                               ; Highlight yank position or call `M-x' in echo area.
    (global-set-key [down-mouse-2]   'mouse-flash-position-or-M-x)               ; `mouse-2'
    ;; Highlight line or `M-:'.
    (global-set-key [S-down-mouse-2]      'mouse-scan-lines-or-M-:)              ; `S-mouse-2'
    (global-set-key [mode-line C-mouse-1] 'tear-off-window)            ; `<mode-line> C-mouse-1'
    (define-key ctl-x-5-map "1"           'tear-off-window)                      ; `C-x 5 1'
    (when (> emacs-major-version 23)
      (define-key minibuffer-inactive-mode-map [down-mouse-1] nil)               ; `mouse-1'
      (define-key minibuffer-inactive-mode-map [mouse-1] nil))))                 ; in echo area

(eval-after-load "second-sel"
  '(progn
    (global-set-key (kbd "C-M-y")  (if (fboundp 'secondary-yank|select|move|swap)
                                       'secondary-yank|select|move|swap
                                     'secondary-dwim))                           ; `C-M-y'
    (define-key esc-map "y"                     'yank-pop-commands)              ; `M-y'
    (define-key isearch-mode-map (kbd "C-M-y")  'isearch-yank-secondary)         ; `C-M-y'
    (global-set-key (kbd "C-x C-M-SPC")         'set-secondary-start)            ;`C-x C-M-SPC'
    (global-set-key (kbd "C-x C-M-<return>")    'secondary-save-then-kill)))     ;`C-x C-M-RET'

(eval-after-load "narrow-indirect"
  '(progn
    (define-key ctl-x-4-map "nd" 'ni-narrow-to-defun-indirect-other-window)      ; `C-x 4 n d'
    (define-key ctl-x-4-map "nn" 'ni-narrow-to-region-indirect-other-window)     ; `C-x 4 n n'
    (define-key ctl-x-4-map "np" 'ni-narrow-to-page-indirect-other-window)))     ; `C-x 4 n p'

;; Because C-M- is being used for secondary.
(eval-after-load "foldout" '(setq foldout-mouse-modifiers '(meta shift)))

(eval-after-load "oneonone" ; Bind `1on1-fit-minibuffer-frame' to `M-up' in minubuffer maps.
  '(when (framep 1on1-minibuffer-frame) ; Standalone minibuffer frame.
    (define-key minibuffer-local-map [(meta up)] '1on1-fit-minibuffer-frame)
    (unless (eq minibuffer-local-map (keymap-parent minibuffer-local-completion-map))
      (define-key minibuffer-local-must-match-map [(meta up)] '1on1-fit-minibuffer-frame)
      (define-key minibuffer-local-completion-map [(meta up)] '1on1-fit-minibuffer-frame))
    (when (boundp 'minibuffer-local-filename-completion-map)
      (define-key minibuffer-local-filename-completion-map [(meta up)]
        '1on1-fit-minibuffer-frame))
    (when (boundp 'minibuffer-local-must-match-filename-map) ; Emacs 22
      (define-key minibuffer-local-must-match-filename-map [(meta up)]
        '1on1-fit-minibuffer-frame))
    (when (boundp 'minibuffer-local-filename-must-match-map) ; Emacs 23+
      (define-key minibuffer-local-filename-must-match-map [(meta up)]
        '1on1-fit-minibuffer-frame))
    (when (boundp 'minibuffer-local-isearch-map)
      (unless (eq minibuffer-local-map (keymap-parent minibuffer-local-isearch-map))
        (define-key minibuffer-local-isearch-map [(meta up)] '1on1-fit-minibuffer-frame)))
    (when (boundp 'minibuffer-local-shell-command-map)
      (unless (eq minibuffer-local-map (keymap-parent minibuffer-local-shell-command-map))
        (define-key minibuffer-local-shell-command-map [(meta up)] '1on1-fit-minibuffer-frame)))
    (when (boundp 'minibuffer-inactive-mode-map)
      (define-key minibuffer-inactive-mode-map [(meta up)] '1on1-fit-minibuffer-frame))))

(eval-after-load "frame-cmds"
  '(progn
    (global-set-key [(meta up)]             'move-frame-up)                      ; `M-up'
    (global-set-key [(meta down)]           'move-frame-down)                    ; `M-down'
    (global-set-key [(meta left)]           'move-frame-left)                    ; `M-left'
    (global-set-key [(meta right)]          'move-frame-right)                   ; `M-right'
    (global-set-key [(meta shift ?v)]       'move-frame-to-screen-top)           ; `M-S-v'
    (global-set-key [(control shift ?v)]    'move-frame-to-screen-bottom)        ; `C-S-v'
    (global-set-key [(control shift prior)] 'move-frame-to-screen-left)          ; `C-S-prior'
    (global-set-key [(control shift next)]  'move-frame-to-screen-right)         ; `C-S-next'
    (global-set-key [(control shift home)]  'move-frame-to-screen-top-left)      ; `C-S-home'
    (global-set-key [(control meta up)]     'shrink-frame)                       ; `C-M-up'
    (global-set-key [(control meta down)]   'enlarge-frame)                      ; `C-M-down'
    (global-set-key [(control meta left)]   'shrink-frame-horizontally)          ; `C-M-left'
    (global-set-key [(control meta right)]  'enlarge-frame-horizontally)         ; `C-M-right'
    ;; Replaces`iconify-or-deiconify-frame'.
    (global-set-key [(control ?z)] 'iconify/map-frame)                           ; `C-z'
    ;; $$$$ (global-set-key [(control ?x) (control ?z)] 'iconify-everything)
    (global-set-key [(shift control meta ?z)] 'show-hide)                        ; `C-M-S-z'
    (global-set-key [C-down-mouse-1]        'mouse-show-hide-mark-unmark)        ; `C-mouse-1'
    (global-set-key [C-mouse-1]            'ignore)
    (global-set-key [S-down-mouse-1]       nil) ; Get rid of `mouse-set-font'.   ; `S-mouse-1'
    ;;(global-set-key [vertical-line mouse-1] 'ignore)
    (global-set-key [vertical-line C-down-mouse-1] 'show-hide)
    ;;(global-set-key [vertical-line C-mouse-1] 'ignore)
    (global-set-key [vertical-line S-down-mouse-1] 'iconify-everything)
    ;;(global-set-key [vertical-line S-mouse-1] 'ignore)
    ;; [mode-line mouse-3] as deletion (Emacs std) is too hazardous.  Iconify instead.
    (global-set-key [mode-line mouse-3]     'mouse-iconify/map-frame)
    (global-set-key [mode-line C-mouse-3]   'mouse-remove-window)))

(eval-after-load "framemove"
  '(progn
    (global-set-key [(shift meta up)]    'fm-up-frame)                           ; `M-S-up'
    (global-set-key [(shift meta down)]  'fm-down-frame)                         ; `M-S-down'
    (global-set-key [(shift meta left)]  'fm-left-frame)                         ; `M-S-left'
    (global-set-key [(shift meta right)] 'fm-right-frame)))                      ; `M-S-right'

(eval-after-load "zoom-frm"             ; `zoom-frm.el' requires `frame-cmds.el'.
  '(progn
    (global-set-key [S-mouse-1] 'zoom-in)                                     ; `S-mouse-1'
    (global-set-key [C-S-mouse-1] 'zoom-out)                                  ; `C-S-mouse-1'
    (global-set-key (if (boundp 'mouse-wheel-down-event)                      ; `C-mouse-wheel'
                        (vector (list 'control mouse-wheel-down-event))
                      [C-mouse-wheel])  ; Emacs 20, 21
     'zoom-in)
    (when (boundp 'mouse-wheel-up-event)
      (global-set-key (vector (list 'control mouse-wheel-up-event)) 'zoom-out))

    (when (fboundp 'text-scale-adjust)  ; Emacs 23+
      (define-key ctl-x-map [(control ?+)] 'zoom-in/out)                         ; `C-x +'
      (define-key ctl-x-map [(control ?-)] 'zoom-in/out)                         ; `C-x -'
      (define-key ctl-x-map [(control ?=)] 'zoom-in/out)                         ; `C-x ='
      (define-key ctl-x-map [(control ?0)] 'zoom-in/out))))                      ; `C-x 0'

;;;   ;; These [nil] bindings are no doubt a HACK, based on an undocumented handy "feature".
;;;   ;; (This works in Emacs 19.34.6, but it doesn't work in Emacs 20.6.)
;;;   ;; In Windows, at least, such a key sequence [nil...] occurs if you click in the
;;;   ;; lower right corner, between the scroll bar and the mode-line.
;;;   (global-set-key [nil down-mouse-1] 'fit-frame)
;;;   (global-set-key [nil mouse-1] 'ignore)
;;;   (global-set-key [nil C-down-mouse-1] 'show-hide)
;;;   (global-set-key [nil C-mouse-1] 'ignore)
;;;   (global-set-key [nil S-down-mouse-1] 'iconify-everything)
;;;   (global-set-key [nil S-mouse-1] 'ignore)

;; These are defined in `fit-frame.el'.
(eval-after-load "fit-frame"
  '(progn
    (global-set-key [(control ?x) (control ?_)] 'fit-frame)                      ; `C-x C-_'
    (global-set-key [vertical-line down-mouse-1] 'fit-frame-or-mouse-drag-vertical-line)))

(eval-after-load "iedit"
  '(progn
    (define-key global-map       (kbd "C-;") 'iedit-mode)                        ; `C-;'
    (define-key isearch-mode-map (kbd "C-;") 'iedit-mode)))

;;; Put *Help* buffer in `help-minor-mode'.
;;(save-excursion (set-buffer (get-buffer-create "*Help*")) (help-minor-mode 1))

;;;; Help mouse-menu.
;;(when (fboundp 'help-mouse-menu)        ; In `help-minor.el'.
;;  (unless (lookup-key (current-global-map) [C-M-S-down-mouse-1])
;;    (global-set-key [C-M-S-down-mouse-1] 'help-mouse-menu)
;;    (global-set-key [C-M-S-mouse-1] 'ignore))
;;  (unless (lookup-key (current-global-map) [C-M-S-down-mouse-2])
;;    (global-set-key [C-M-S-down-mouse-2] 'help-mouse-menu)
;;    (global-set-key [C-M-S-mouse-2] 'ignore))
;;  (unless (lookup-key (current-global-map) [C-M-S-down-mouse-3])
;;    (global-set-key [C-M-S-down-mouse-3] 'help-mouse-menu)
;;    (global-set-key [C-M-S-mouse-3] 'ignore)))

;; Comparisons: windows, buffers, files.
(global-set-key [(control meta ?=)] (if (fboundp 'compare-windows-repeat)
                                        'compare-windows-repeat ; In `misc-cmds.el'.
                                      'compare-windows)) ; In `compare-w.el'.
(defvar comparison-map (lookup-key global-map [?\C-=])
  "Prefix keymap for comparison commands.")
(unless (keymapp comparison-map)
  (setq comparison-map (make-sparse-keymap))
  (global-set-key [(control ?=)] comparison-map)
  (define-key comparison-map "b" 'ediff-buffers) ; In `ediff.el'.                ; `C-= b'
  (define-key comparison-map "e" 'ediff-files) ; In `ediff.el'.                  ; `C-= e'
  (define-key comparison-map "f" 'ediff-files) ; In `ediff.el'.                  ; `C-= f'
  (define-key comparison-map "d" 'diff) ; In `diff+.el'.                         ; `C-= d'
  (define-key comparison-map "w" (if (fboundp 'compare-windows-repeat)           ; `C-= w'
                                     'compare-windows-repeat ; In `misc-cmds.el'.
                                   'compare-windows))) ; In `compare-w.el'.

;; Completions (non-minibuffer).
;(global-set-key "\M-\r" 'complete)      ; Defined in `completion.el':
;(global-set-key [?\C-\r] 'complete)
;(define-key function-key-map [C-return] [?\C-\r])

(eval-after-load "fill"
  '(define-key text-mode-map [(meta ?j)] 'fill-individual-paragraphs))           ; `M-j'

(eval-after-load "ispell"
  '(global-set-key [(meta ?$)] 'ispell-complete-word))                           ; `M-$'

(eval-after-load "thingatpt"
  '(progn
    (global-set-key [(meta ?_)] 'forward-whitespace)                             ; `M-_'
    ;; Emacs 23 co-opts `M-s-' as a prefix key.
    (unless (lookup-key global-map [(meta ?s)])                                  ; `M-s-'
      (global-set-key [(meta ?s)] 'forward-symbol)))) ; Defined in `thingatpt.el'

;; These replace the bindings for `mark-sexp' and `mark-word'.  Defined in `thing-cmds.el'.
(eval-after-load "thing-cmds"
  '(progn
    (global-set-key [(control meta ? )] 'select-things)                          ; `C-M-SPC'
    (global-set-key [(meta ?@)] 'cycle-select-something)))                       ; `M-@'

(eval-after-load "crosshairs"
  '(global-set-key [(control ?+)] 'crosshairs-mode))                             ; `C-+'

(eval-after-load "unaccent"
  '(progn
    (global-set-key [(meta ?\")] 'unaccent-word)                                 ; `M-"'
    (define-key ctl-x-map [\"] 'unaccent-region)))                               ; `C-x "'

;;; Do Re Mi commands
(eval-after-load "doremi-frm"
  '(progn
    (unless (fboundp 'doremi-prefix)
      (defalias 'doremi-prefix (make-sparse-keymap))
      (defvar doremi-map (symbol-function 'doremi-prefix)
        "Keymap for Do Re Mi commands."))
    (define-key global-map "\C-xt" 'doremi-prefix)
    (define-key doremi-map "a" 'doremi-all-faces-fg+) ; "All"                    `C-x t a'
    (define-key doremi-map "c" 'doremi-bg+) ; "Color"                            `C-x t c'
    (define-key doremi-map "f" 'doremi-face-fg+) ; Face"                         `C-x t f'
    (define-key doremi-map "h" 'doremi-frame-height+) ; Height                   `C-x t h'
    (define-key doremi-map "k" 'doremi-face-bg+) ; bacKground"                   `C-x t k'
    (define-key doremi-map "t" 'doremi-font+) ; "Typeface"                       `C-x t t'
    (define-key doremi-map "u" 'doremi-frame-configs+) ; "Undo"                  `C-x t u'
    (define-key doremi-map "x" 'doremi-frame-horizontally+) ; X (abscissa)       `C-x t x'
    (define-key doremi-map "y" 'doremi-frame-vertically+)   ; Y (ordinate)       `C-x t y'
    (define-key doremi-map "z" 'doremi-frame-font-size+))) ; "Zoom"              `C-x t z'

(eval-after-load "doremi-cmd"
  '(progn
    (unless (fboundp 'doremi-prefix)
      (defalias 'doremi-prefix (make-sparse-keymap))
      (defvar doremi-map (symbol-function 'doremi-prefix)
        "Keymap for Do Re Mi commands."))
    (define-key global-map "\C-xt"  'doremi-prefix)
    (define-key doremi-map "b" 'doremi-buffers+) ; Buffer                        `C-x t b'
    (define-key doremi-map "g" 'doremi-global-marks+) ; Global mark              `C-x t g'
    (define-key doremi-map "m" 'doremi-marks+) ; Mark                            `C-x t m'
    (define-key doremi-map "r" 'doremi-bookmarks+) ; `r' for Reading books       `C-x t r'
    (define-key doremi-map "s" (if (fboundp 'doremi-custom-themes+)
                                   'doremi-custom-themes+
                                 'doremi-color-themes+)) ; `s' for color Schemes `C-x t s'
    (define-key doremi-map "w" 'doremi-window-height+))) ; Window                `C-x t w'

(eval-after-load "frame-cmds"
  '(progn
    (unless (fboundp 'doremi-prefix)
      (defalias 'doremi-prefix (make-sparse-keymap))
      (defvar doremi-map (symbol-function 'doremi-prefix)
        "Keymap for Do Re Mi commands."))
    (define-key global-map "\C-xt"  'doremi-prefix)
    (define-key doremi-map "." 'save-frame-config)))                           ; `C-x t .'

(eval-after-load "thumb-frm"
  '(progn
    (global-set-key [(shift mouse-3)]         'thumfr-toggle-thumbnail-frame)  ; `S-mouse-3'
    (global-set-key [(shift control mouse-3)] 'thumfr-thumbify-other-frames)   ; `C-S-mouse-3'
    (global-set-key [(shift control ?z)]      'thumfr-thumbify-other-frames)   ; `C-S-z'
    (global-set-key [(shift control ?n)]      'thumfr-fisheye-next-frame)      ; `C-S-n'
    (global-set-key [(shift control ?p)]      'thumfr-fisheye-previous-frame)  ; `C-S-p'
    (global-set-key [(control meta ?z)]    'thumfr-really-iconify-or-deiconify-frame) ; `C-M-z'
    ;; `e' for eye (fisheye)
    (define-key global-map "\C-xte" 'thumfr-doremi-thumbnail-frames+)          ; `C-x t e'
    ;; Make window-manager "minimize" button thumbify instead of iconify.
    ;; (define-key special-event-map [iconify-frame] 'thumfr-thumbify-frame-upon-event)
    ))

(eval-after-load "ucs-cmds"
  '(when (> emacs-major-version 22)     ; Need Emacs 23+ version of `insert-char'/`ucs-insert'.
    (when (commandp 'insert-char)       ; `ucs-insert' renamed to `insert-char' in Emacs 24.
      (define-key global-map [remap insert-char] 'ucsc-insert))
    (when (fboundp 'ucs-insert)
      (define-key global-map [remap ucs-insert] 'ucsc-insert))))

(define-key help-map "\C-\M-f" 'describe-face)                                 ; `C-h C-M-f'

;; `C-x' stuff.
;;
;; So you can do it with one hand.
(define-key ctl-x-map [(control ?z)] 'delete-window)                           ; `C-x C-z'

(eval-after-load "misc-cmds"
  '(progn
    (define-key ctl-x-map [home] 'mark-buffer-before-point)                    ; `C-x home'
    (define-key ctl-x-map [end]  'mark-buffer-after-point)                     ; `C-x end'
    (define-key ctl-x-map [(control ?\;)] 'comment-region-lines)               ; `C-x C-;'
    (define-key ctl-x-map "\M-f" 'region-to-file)                              ; `C-x M-f'
    (define-key ctl-x-map "L"    'goto-longest-line)                           ; `C-x L'
    (when (fboundp 'undo-repeat) (global-set-key [remap undo] 'undo-repeat))   ; `C-x u' etc.
    (when (fboundp 'next-buffer-repeat)
      (global-set-key [remap previous-buffer] 'previous-buffer-repeat)         ; `C-x left'
      (global-set-key [remap next-buffer]     'next-buffer-repeat))))          ; `C-x right'

;; In `chistory.el'.
(define-key ctl-x-map [(meta ?x)] 'repeat-matching-complex-command)            ; `C-x M-x'
(define-key ctl-x-map "c" 'font-lock-mode)                                     ; `C-x c'

(eval-after-load "frame-cmds"
  '(define-key ctl-x-map "o" 'other-window-or-frame))                          ; `C-x o'

(eval-after-load "highlight"
  '(progn
    (define-key ctl-x-map [(control ?y)] 'hlt-highlight)                       ; `C-x C-y'
    (define-key ctl-x-map [(down-mouse-2)] 'hlt-highlighter)                   ; `C-x mouse-2'
    (define-key ctl-x-map [(mouse-2)] 'ignore)
    (define-key ctl-x-map [(S-down-mouse-2)] 'hlt-eraser)                     ; `C-x S-mouse-2'
    (when (fboundp 'next-single-char-property-change) ; Emacs 21+
      (global-set-key [(shift control ?p)] 'hlt-previous-highlight)            ; `C-S-p'
      (global-set-key [(shift control ?n)] 'hlt-next-highlight))               ; `C-S-n'
    (global-set-key [(control meta shift ?s)] 'hlt-highlight-enclosing-list))) ; `C-M-S'

(eval-after-load "highlight-symbol"
  '(progn
    (global-set-key [(control f9)] 'highlight-symbol-at-point)                 ; `C-f9'
    (global-set-key [f9]           'highlight-symbol-next)                     ; `f9'
    (global-set-key [(shift f9)]   'highlight-symbol-prev)                     ; `S-f9'
    (global-set-key [(meta f3)]    'highlight-symbol-query-replace)))          ; `M-f9'

(eval-after-load "dired-x"
  '(progn
    (define-key ctl-x-map   [(control ?j)] 'dired-jump)                        ; `C-x j'
    (define-key ctl-x-4-map [(control ?j)] 'dired-jump-other-window)))         ; `C-x 4 j'

(eval-after-load "frame-cmds"
  '(progn
    (define-key ctl-x-4-map "1" 'delete-other-frames)                          ; `C-x 4 1'
    (define-key ctl-x-5-map "h" 'show-*Help*-buffer)))                         ; `C-x 5 h'

(eval-after-load "find-func+"           ; Emacs 22+
  '(define-key ctl-x-4-map "l" 'find-library-other-window))                    ; `C-x 4 l'
(find-function-setup-keys)  ;; C-x F, C-x 4 F, C-x 5 F, C-x K, C-x V, C-x 4 V, C-x 5 V

;; [f1] function key.
;;; (eval-after-load "help+"
;;;   ;; Standard binding is `help-command'
;;;   '(global-set-key [f1] 'help-on-click/key))                                   ; `f1'
;;; (eval-after-load "help+20"
;;;   '(global-set-key [f1] 'help-on-click/key))

(eval-after-load "misc-cmds"
  '(global-set-key [C-S-f1] 'region-to-buffer))                                ; `C-S-f1'

(global-set-key [M-S-f1] 'insert-buffer) ; Defined in `simple.el'.             ; `M-S-f1'
;; Defined in `font-lock.el'
(global-set-key [C-M-f1] 'font-lock-fontify-buffer)                            ; `C-M-f1'
(global-set-key [C-M-S-f1] 'rename-buffer)                                     ; `C-M-S-f1'

;; [f3] function key.
(eval-after-load "bm"
  '(progn
    (global-set-key (kbd "<S-f3>") 'bm-toggle)                                 ; `S-f3'
    (global-set-key (kbd "<C-f3>") 'bm-next)                                   ; `C-f3'
    (global-set-key (kbd "<M-f3>") 'bm-previous)))                             ; `M-f3'

;; [f5] function key - a la MS Windows.
(global-set-key [f5] 'revert-buffer)                                           ; `f5'
(eval-after-load "misc-cmds"
  '(global-set-key [f5] 'revert-buffer-no-confirm))                            ; `f5'

;; [insert] key.  [C-insert] is `kill-ring-save'.  [S-insert] is `yank'.
(global-set-key [M-insert] 'yank-pop) ; Defined in `simple.el'.                ; `M-insert'
(global-set-key [C-S-insert] 'insert-buffer) ; Defined in `simple.el'.         ; `C-S-insert'
(global-set-key [M-S-insert] 'yank-rectangle)                                  ; `M-S-insert'
(global-set-key [C-M-insert] 'lisp-complete-symbol)                            ; `C-M-insert'
(global-set-key [C-M-S-insert] 'insert-file)                                   ; `C-M-S-insert'

(eval-after-load "fuzzy-match"
  '(global-set-key "\M-#" 'lisp-spell-symbol))                                 ; `M-#'

;; [delete] key.
(global-set-key [C-delete] 'kill-paragraph) ; Defined in `paragraphs.el'.        `C-delete'
(global-set-key [M-delete] 'kill-ring-save) ; Defined in `simple.el'.            `M-delete'
; Emacs standard: [S-delete] is `kill-region'.
(global-set-key [C-S-delete] 'append-next-kill) ; Defined in `simple.el'.        `C-S-delete'
(global-set-key [M-S-delete] 'kill-rectangle) ; Defined in `rect.el'.            `M-S-delete'
(global-set-key [C-M-delete] 'kill-sexp) ; Defined in `lisp.el'.                 `C-M-delete'
(global-set-key [C-M-S-delete] 'append-to-register) ; Defined in `register.el'.  `C-M-S-delete'

;; [backspace] key.
(global-set-key [C-backspace] 'backward-kill-paragraph) ; In `paragraphs.el'.    `C-backspace'

(eval-after-load "misc-cmds"
  '(global-set-key [C-S-backspace] 'region-to-file))                        ; `C-S-backspace'

(global-set-key [M-S-backspace] 'clear-rectangle) ; Defined in `rect.el'.     `M-S-backspace'
; This was standard in Emacs 20:
(global-set-key [C-M-backspace] 'backward-kill-sexp) ; In  `lisp.el'.         `C-M-backspace'
(global-set-key [C-M-S-backspace] 'copy-to-register) ; In `register.el'.      `C-M-S-backspace'

;; [pause] / [break] key:
;; NOTE: On Windows, [C-pause] is considered to be [C-cancel].  Still true for XP?

;; Better than the standard bindings `C-x <right>' and `C-x <right>',
;; because you can hold these down to repeat: cycle through buffers.
(when (fboundp 'next-buffer)            ; Emacs 21+.
  (global-set-key [C-pause] 'previous-buffer)                                   ; `C-pause'
  (global-set-key [M-pause] 'next-buffer))                                      ; `M-pause'

;; `iso-transl.el' is needed to use an ISO prefix key (e.g. `C-x 8'. [f8]).
;; It defines `key-translation-map'.
(require 'iso-transl)
;;;@@@Emacs20 ;; This lets users do `[f8] C-h]' for help on ISO chars.
;;;@@@Emacs20 (autoload 'help-iso-prefix "help+"
;;;@@@Emacs20   "Show commands bound to ISO (pseudo-)prefix key sequences." t)

  ;; Make [f8] key be a synonym for `C-x 8'. (Use [f8] as a compose key.)
(define-key key-translation-map [f8]   ; See `iso-transl.el'.                   ; `f8'
  (lookup-key key-translation-map "\C-x8"))

;; Make [f8] key be a synonym for `C-x 8' for isearch too.
;; This lets you search for accented chars using [f8].
(define-key isearch-mode-map [f8] nil)
;;;@@@Emacs20 ;; [f8] C-h and C-x 8 C-h  :=  Help for [f8] and C-x 8 prefixes:
;;;@@@Emacs20 (global-set-key (vector 'f8 help-char) 'help-iso-prefix) ; In `help.el'.
;;;@@@Emacs20 (define-key ctl-x-map "8\C-h" 'help-iso-prefix) ; Defined in `help.el'.

;; These *declp* commands are defined in `misc-cmds.el'.
;(global-set-key [C-print] 'declp-buffer) ; Print buffer. (defsubst)
;(global-set-key [M-print] 'pr-declp-buffer) ; Print buffer via `pr'.
;(global-set-key [C-M-print] 'declp-buffer-w-switches) ; User `declp' switches.
;(global-set-key [S-print] 'transpose-paragraphs) ; Defined in `paragraphs.el'
;(global-set-key [C-S-print] 'declp-region) ; Print region. (defsubst)
;(global-set-key [M-S-print] 'pr-declp-region) ; Print region via `pr'.
;(global-set-key [C-M-S-print] 'declp-region-w-switches) ; `declp' + switches.

;; [home], [end], [prior], and [next] keys.  These are used, unmodified, by
;; `s-region-move', which is defined in `s-region+.el'.  The following commands,
;; except `forward-page' & `backward-page', are also defined in `s-region+.el'.
;(global-set-key [C-prior] 'backward-page) ; Defined in `page.el'.
;(global-set-key [C-previous] 'backward-page)
;(global-set-key [C-next] 'forward-page) ; Defined in `page.el'.
;(global-set-key [next] 'scroll-up-windowful) ; Defined in `s-region+.el'.
;(global-set-key [previous] 'scroll-down-windowful) ; Defined in `s-region+.el'.
;(global-set-key [prior] 'scroll-down-windowful)
;(global-set-key [M-next] 'scroll-other-window-up-windowful) ; In `s-region+.el'
;(global-set-key [M-previous] 'scroll-other-window-down-windowful)
;(global-set-key [M-prior] 'scroll-other-window-down-windowful) ; `s-region+.el'
;(global-set-key [home] 'goto-point-min) ; (defsubst) Defined in `s-region+.el'.
;(global-set-key [end] 'goto-point-max) ; (defsubst) Defined in `s-region+.el'.
;(global-set-key [M-home] 'bob-other-window) ; (defsubst) In `s-region+.el'.
;(global-set-key [M-end] 'eob-other-window) ; (defsubst) In `s-region+.el'.
;(s-region-bind (list [prior] [C-prior] [M-prior]))

(eval-after-load "swiss-move"
  '(progn
    (global-set-key [S-prior] 'swiss-move-line-up)                            ; `S-prior'
    (global-set-key [S-next]  'swiss-move-line-down)))                        ; `S-next'

;; [up], [down], [left], [right] keys.
(global-set-key [S-down] (lambda () (interactive) (scroll-up 1)))                  ; `S-down'
(global-set-key [S-up] (lambda () (interactive) (scroll-down 1)))                  ; `S-up'
;;(global-set-key [M-up] (lookup-key esc-map "p")) ; Probably not defined.
;;(global-set-key [M-down] (lookup-key esc-map "n")) ; Probably not defined.
;;(global-set-key [M-left] (lookup-key esc-map "b")) ; Predefined.
;;(global-set-key [M-right] (lookup-key esc-map "f")) ; Predefined.
(global-set-key [C-M-home] 'beginning-of-defun)                               ; `C-M-home'
(global-set-key [C-M-end] 'end-of-defun)                                      ; `C-M-end'

(eval-after-load "misc-cmds"
  '(progn
    (global-set-key "\M-p" 'back-to-indentation+)                             ; `M-p'
    (global-set-key "\M-n" 'forward-to-indentation+)))                        ; `M-n'

;;;-----------REPLACEMENT BINDINGS------------------------------------

(defvar sub-*-of-line t
  "*Non-nil means remap `*-of-line' commands to `*-of-line+' globally.
This applies to `move-to-(beginning|end)-of-line', if defined, or to
`(beginning|end)-of-line', otherwise.
This has no effect unless you use library `misc-cmds.el'.")

(defvar sub-clone-frame t
  "*Non-nil means remap `make-frame-command' to `clone-frame' globally.
This has no effect unless you use library `frame-cmds.el'.")

(defvar sub-delete-windows-for t
  "*Non-nil means remap `delete-window' to `delete-windows-for' globally.
This has no effect unless you use library `frame-cmds.el'.")

(defvar sub-kill-buffer-and-its-windows t
  "*Non-nil means remap `kill-buffer' to `kill-buffer-and-its-windows' globally.
This has no effect unless you use library `misc-cmds.el'.")

(defvar sub-pp-evals t
  "*Non-nil means remap `eval-*' commands to `pp-eval-*' globally.
Thus, `pp-eval-expression' replaces `eval-expression' and
`pp-eval-last-sexp' replaces `eval-last-sexp'.
This has no effect unless you use library `pp+.el'.")

(defvar sub-query-replace-w-options t
  "*Non-nil means remap `query-replace' to `query-replace-w-options' globally.
This has no effect unless you use library `replace+.el'.")

(defvar sub-quit-window-delete (fboundp 'quit-restore-window) ; Emacs 24.3+
  "*Non-nil means remap `quit-window' to `quit-window-delete' globally.
This has no effect unless you use library `misc-cmds.el' and Emacs
24.4 or later.")

(defvar sub-recenter-top-bottom t
  "*Non-nil means remap `recenter' to `sub-recenter-top-bottom' globally.
This has no effect unless you use library `misc-cmds.el'.")

(defvar sub-transpose-sexps t
  "*Non-nil means remap `transpose-sexps' to `reversible-transpose-sexps'.
This has no effect unless you use library `misc-cmds.el'.")


;;; Do these all *after* load `menu-bar+.el', since that sets original bindings.

(eval-after-load "frame-cmds"
  '(progn
    (when sub-delete-windows-for
      (remap-command 'delete-window 'delete-windows-for global-map))
    (when sub-clone-frame
      (remap-command 'make-frame-command 'clone-frame global-map))))
(eval-after-load "replace+"
  '(when sub-query-replace-w-options
    (remap-command 'query-replace 'query-replace-w-options global-map)))
(eval-after-load "misc-cmds"
  '(when sub-kill-buffer-and-its-windows
    (remap-command 'kill-buffer 'kill-buffer-and-its-windows global-map)))
(eval-after-load "pp+"
  '(when sub-pp-evals
    (remap-command 'eval-last-sexp 'pp-eval-last-sexp global-map)
    (remap-command 'eval-expression 'pp-eval-expression global-map)))
(when (fboundp 'buffer-menu)
  (remap-command 'list-buffers 'buffer-menu global-map)) ; In `buff-menu+.el'.
(eval-after-load "misc-cmds"
  '(progn
    (when sub-*-of-line
      (cond ((fboundp 'move-beginning-of-line)
             (remap-command 'move-beginning-of-line 'beginning-of-line+ global-map)
             (remap-command 'move-end-of-line 'end-of-line+ global-map))
            (t
             (remap-command 'beginning-of-line 'beginning-of-line+ global-map)
             (remap-command 'end-of-line 'end-of-line+ global-map)))
      (when (boundp 'visual-line-mode-map)
        (define-key visual-line-mode-map [remap move-beginning-of-line] nil)
        (define-key visual-line-mode-map [remap move-end-of-line]       nil)
        (define-key visual-line-mode-map [home] 'beginning-of-line+)
        (define-key visual-line-mode-map [end]  'end-of-line+)
        (define-key visual-line-mode-map "\C-a" 'beginning-of-visual-line+)
        (define-key visual-line-mode-map "\C-e" 'end-of-visual-line+)))
    (when sub-recenter-top-bottom
      (remap-command 'recenter 'recenter-top-bottom global-map))
    (when sub-transpose-sexps
      (remap-command 'transpose-sexps 'reversible-transpose-sexps global-map))))
(eval-after-load "misc-cmds"
  '(when sub-quit-window-delete
    (remap-command 'quit-window 'quit-window-delete global-map)))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'setup-keys)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; setup-keys.el ends here
#+end_src

** quelpa.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; quelpa.el --- Emacs Lisp packages built directly from source

;; Copyright 2014-2021, Steckerhalter
;; Copyright 2014-2015, Vasilij Schneidermann <v.schneidermann@gmail.com>

;; Author: steckerhalter
;; URL: https://github.com/quelpa/quelpa
;; Version: 1.0
;; Package-Requires: ((emacs "25.1"))
;; Keywords: tools package management build source elpa

;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:

;; Your personal local Emacs Lisp Package Archive (ELPA) with packages
;; built on-the-fly directly from source.

;; See the README for more info:
;; https://github.com/quelpa/quelpa/blob/master/README.org

;;; Requirements:

;; Emacs 25.1

;;; Code:

(require 'cl-lib)
(require 'help-fns)
(require 'url-parse)
(require 'package)
(require 'lisp-mnt)
(eval-when-compile (require 'subr-x))

;; --- customs / variables ---------------------------------------------------

(defgroup quelpa nil
  "Build and install packages from source code"
  :group 'package)

(defcustom quelpa-upgrade-p nil
  "When non-nil, `quelpa' will try to upgrade packages.
The global value can be overridden for each package by supplying
the `:upgrade' argument."
  :group 'quelpa
  :type 'boolean)

(defcustom quelpa-stable-p nil
  "When non-nil, try to build stable packages like MELPA does."
  :group 'quelpa
  :type 'boolean)

(defcustom quelpa-autoremove-p t
  "When non-nil, automatically remove old packages after upgrading.
The global value can be overridden for each package by supplying the
`:autoremove' argument."
  :group 'quelpa
  :type 'boolean)

(defcustom quelpa-verbose t
  "When non-nil, `quelpa' prints log messages."
  :group 'quelpa
  :type 'boolean)

(defcustom quelpa-before-hook nil
  "List of functions to be called before quelpa."
  :group 'quelpa
  :type 'hook)

(defcustom quelpa-after-hook nil
  "List of functions to be called after quelpa."
  :group 'quelpa
  :type 'hook)

(defcustom quelpa-dir (expand-file-name "quelpa" user-emacs-directory)
  "Where quelpa builds and stores packages."
  :group 'quelpa
  :type 'string)

(defcustom quelpa-melpa-dir (expand-file-name "melpa" quelpa-dir)
  "Where the melpa repo cloned to."
  :group 'quelpa
  :type 'string)

(defcustom quelpa-build-dir (expand-file-name "build" quelpa-dir)
  "Where quelpa builds packages."
  :group 'quelpa
  :type 'string)

(defcustom quelpa-packages-dir (expand-file-name "packages" quelpa-dir)
  "Where quelpa puts built packages."
  :group 'quelpa
  :type 'string)

(defcustom quelpa-melpa-recipe-stores (list (expand-file-name
                                             "recipes"
                                             quelpa-melpa-dir))
  "Recipe stores where quelpa finds default recipes for packages.
A store can either be a string pointing to a directory with
recipe files or a list with recipes."
  :group 'quelpa
  :type '(repeat
          (choice directory
                  (repeat
                   :tag "List of recipes"
                   (restricted-sexp :tag "Recipe"
                                    :match-alternatives (listp))))))

(defcustom quelpa-persistent-cache-file (expand-file-name "cache" quelpa-dir)
  "Location of the persistent cache file."
  :group 'quelpa
  :type 'string)

(defcustom quelpa-persistent-cache-p t
  "Non-nil when quelpa's cache is saved on and read from disk."
  :group 'quelpa
  :type 'boolean)

(defcustom quelpa-checkout-melpa-p t
  "If non-nil the MELPA git repo is cloned when quelpa is initialized."
  :group 'quelpa
  :type 'boolean)

(defcustom quelpa-update-melpa-p t
  "If non-nil the MELPA git repo is updated when quelpa is initialized.
If nil the update is disabled and the repo is only updated on
`quelpa-upgrade' or `quelpa-self-upgrade'."
  :group 'quelpa
  :type 'boolean)

(defcustom quelpa-melpa-repo-url "https://github.com/melpa/melpa.git"
  "The melpa git repository url."
  :group 'quelpa
  :type 'string)

(defcustom quelpa-self-upgrade-p t
  "If non-nil upgrade quelpa itself when doing a
`quelpa-upgrade-all', otherwise only upgrade the packages in the
quelpa cache."
  :group 'quelpa
  :type 'boolean)

(defcustom quelpa-git-clone-depth nil
  "If non-nil shallow clone quelpa git recipes."
  :group 'quelpa
  :type '(choice (const :tag "Don't shallow clone" nil)
                 (integer :tag "Depth")))

(defcustom quelpa-git-clone-partial :blobless
  "If non-nil partially clone quelpa git recipes."
  :group 'quelpa
  :type '(choice (const :tag "Don't partially clone" nil)
                 (const :tag "Blobless clone" :blobless)
                 (const :tag "Treeless clone" :treeless)))

(defcustom quelpa-upgrade-interval nil
  "Interval in days for `quelpa-upgrade-all-maybe'."
  :group 'quelpa
  :type '(choice (const :tag "Don't upgrade" nil)
                 (integer :tag "Days")))

(defvar quelpa-initialized-p nil
  "Non-nil when quelpa has been initialized.")

(defvar quelpa-cache nil
  "The `quelpa' command stores processed pkgs/recipes in the cache.")

(defvar quelpa-recipe '(quelpa :repo "quelpa/quelpa" :fetcher github)
  "The recipe for quelpa.")

;; --- package building ------------------------------------------------------

(defun quelpa-package-type (file)
  "Determine the package type of FILE.
Return `tar' for tarball packages, `single' for single file
packages, or nil, if FILE is not a package."
  (let ((ext (file-name-extension file)))
    (cond
     ((string= ext "tar") 'tar)
     ((string= ext "el") 'single)
     (:else nil))))

(defun quelpa-get-package-desc (file)
  "Extract and return the PACKAGE-DESC struct from FILE.
On error return nil."
  (let* ((kind (quelpa-package-type file))
         (desc (with-demoted-errors "Error getting PACKAGE-DESC: %s"
                 (with-temp-buffer
                   (pcase kind
                     (`single (insert-file-contents file)
                              (package-buffer-info))
                     (`tar (insert-file-contents-literally file)
                           (tar-mode)
                           (with-no-warnings
                             (package-tar-file-info))))))))
    (when (package-desc-p desc)
      desc)))

(defun quelpa-archive-file-name (archive-entry)
  "Return the path of the file in which the package for ARCHIVE-ENTRY is stored."
  (let* ((name (car archive-entry))
         (pkg-info (cdr archive-entry))
         (version (package-version-join (aref pkg-info 0)))
         (flavour (aref pkg-info 3)))
    (expand-file-name
     (format "%s-%s.%s" name version (if (eq flavour 'single) "el" "tar"))
     quelpa-packages-dir)))

(defconst quelpa--min-ver '(0 -10) "Smallest possible version.")
(defun quelpa-version-cmp (name version op)
  "Return non-nil if version of pkg with NAME and VERSION satisfies OP.
OP is taking two version list and comparing."
  (let ((ver (if version (version-to-list version) quelpa--min-ver))
        (pkg-ver
         (or (when-let ((pkg-desc (cdr (assq name package-alist)))
                        (pkg-ver (package-desc-version (car pkg-desc))))
               pkg-ver)
             (alist-get name package--builtin-versions)
             quelpa--min-ver)))
    (funcall op ver pkg-ver)))

(defmacro quelpa-version>-p (name version)
  "Return non-nil if VERSION of pkg with NAME is newer than what is currently installed."
  `(quelpa-version-cmp ,name ,version (lambda (o1 o2) (not (version-list-<= o1 o2)))))

(defmacro quelpa-version<-p (name version)
  "Return non-nil if VERSION of pkg with NAME is older than what is currently installed."
  `(quelpa-version-cmp ,name ,version 'version-list-<))

(defmacro quelpa-version=-p (name version)
  "Return non-nil if VERSION of pkg with NAME is same which what is currently installed."
  `(quelpa-version-cmp ,name ,version 'version-list-=))

(defun quelpa--package-installed-p (package &optional min-version)
  "Return non-nil if PACKAGE, of MIN-VERSION or newer, is installed.
Like `package-installed-p' but properly check for built-in package even when all
packages are not initialized."
  (or (package-installed-p package (or min-version quelpa--min-ver))
      (package-built-in-p package (or min-version quelpa--min-ver))))

(defvar quelpa--override-version-check nil)
(defun quelpa-checkout (rcp dir)
  "Return the version of the new package given a RCP and DIR.
Return nil if the package is already installed and should not be upgraded."
  (pcase-let ((`(,name . ,config) rcp)
              (quelpa-build-stable quelpa-stable-p)
              (quelpa--override-version-check quelpa--override-version-check))
    (unless (or (and (quelpa--package-installed-p name) (not quelpa-upgrade-p))
                (and (not config)
                     (quelpa-message t "no recipe found for package `%s'" name)))
      (let ((version (condition-case-unless-debug err
                         (quelpa-build-checkout name config dir)
                       (error
                        (error "Failed to checkout `%s': `%s'"
                               name (error-message-string err))))))
        (cond
          ((and quelpa--override-version-check
                (quelpa-version=-p name version))
           (setq version (concat version ".1"))
           version)
          ((or quelpa--override-version-check
               (quelpa-version>-p name version))
           version))))))

(defun quelpa-build (rcp)
  "Build a package from the given recipe RCP.
Uses the `package-build' library to get the source code and build
an elpa compatible package in `quelpa-build-dir' storing it in
`quelpa-packages-dir'.  Return the path to the created file or nil
if no action is necessary (like when the package is installed
already and should not be upgraded etc)."
  (let* ((name (car rcp))
         (build-dir (expand-file-name (symbol-name name) quelpa-build-dir))
         (version (quelpa-checkout rcp build-dir)))
    (prog1
        (if version
            (quelpa-archive-file-name
             (quelpa-build-package (symbol-name name)
                                   version
                                   (quelpa-build--config-file-list (cdr rcp))
                                   build-dir
                                   quelpa-packages-dir))
          (quelpa-build--message "Newer package has been installed. Not upgrading.")
          nil)
      (when (fboundp 'package--quickstart-maybe-refresh)
        (package--quickstart-maybe-refresh)))))

;; --- package-build.el integration ------------------------------------------

(defun quelpa-file-version (file-path type version time-stamp)
  "Return version of file at FILE-PATH."
  (if (eq type 'directory)
      time-stamp
    (cl-letf* ((package-strip-rcs-id-orig (symbol-function 'package-strip-rcs-id))
               ((symbol-function 'package-strip-rcs-id)
                (lambda (str)
                  (or (funcall package-strip-rcs-id-orig (lm-header "package-version"))
                      (funcall package-strip-rcs-id-orig (lm-header "version"))
                      "0"))))
      (concat (mapconcat
               #'number-to-string
               (package-desc-version (quelpa-get-package-desc file-path)) ".")
              (pcase version
                (`original "")
                (_ (concat "pre0." time-stamp)))))))

(defun quelpa-directory-files (path)
  "Return list of directory files from PATH recursively."
  (let ((result '()))
    (mapc
     (lambda (file)
       (if (file-directory-p file)
           (progn
             ;; When directory is not empty.
             (when (cddr (directory-files file))
               (dolist (subfile (quelpa-directory-files file))
                 (add-to-list 'result subfile))))
         (add-to-list 'result file)))
     (mapcar
      (lambda (file) (expand-file-name file path))
      ;; Without first two entries because they are always "." and "..".
      (remove ".." (remove "." (directory-files path)))))
    result))

(defun quelpa-expand-source-file-list (file-path config)
  "Return list of source files from FILE-PATH corresponding to
CONFIG."
  (let ((source-files
         (mapcar
          (lambda (file) (expand-file-name file file-path))
          (quelpa-build--expand-source-file-list file-path config))))
    ;; Replace any directories in the source file list with the filenames of the
    ;; files they contain (so that these files can subsequently be hashed).
    (dolist (file source-files source-files)
      (when (file-directory-p file)
        (setq source-files (remove file source-files))
        (setq source-files (append source-files
                                   (quelpa-directory-files file)))))))

(defun quelpa-slurp-file (file)
  "Return the contents of FILE as a string, or nil if no such
file exists."
  (when (file-exists-p file)
    (with-temp-buffer
      (set-buffer-multibyte nil)
      (setq-local buffer-file-coding-system 'binary)
      (insert-file-contents-literally file)
      (buffer-substring-no-properties (point-min) (point-max)))))

(defun quelpa-check-hash (name config file-path dir &optional fetcher)
  "Check if hash of FILE-PATH is different as in STAMP-FILE.
If it is different save the new hash and timestamp to STAMP-FILE
and return TIME-STAMP, otherwise return OLD-TIME-STAMP."
  (unless (file-directory-p dir)
    (make-directory dir))
  (let* (files
         hashes
         new-stamp-info
         new-content-hash
         (time-stamp
          (replace-regexp-in-string "\\.0+" "." (format-time-string "%Y%m%d.%H%M%S")))
         (stamp-file (concat (expand-file-name (symbol-name name) dir) ".stamp"))
         (old-stamp-info (quelpa-build--read-from-file stamp-file))
         (old-content-hash (cdr old-stamp-info))
         (old-time-stamp (car old-stamp-info))
         (type (if (file-directory-p file-path) 'directory 'file))
         (version (plist-get config :version)))

    (if (not (file-exists-p file-path))
        (error "`%s' does not exist" file-path)
      (if (eq type 'directory)
          (setq files (quelpa-expand-source-file-list file-path config)
                hashes (mapcar
                        (lambda (file)
                          (secure-hash
                           'sha1 (concat file (quelpa-slurp-file file)))) files)
                new-content-hash (secure-hash 'sha1 (mapconcat 'identity hashes "")))
        (setq new-content-hash (secure-hash 'sha1 (quelpa-slurp-file file-path)))))

    (setq new-stamp-info (cons time-stamp new-content-hash))
    (if (and old-content-hash
             (string= new-content-hash old-content-hash))
        (quelpa-file-version file-path type version old-time-stamp)
      (unless (eq fetcher 'url)
        (delete-directory dir t)
        (make-directory dir)
        (if (eq type 'file)
            (copy-file file-path dir t t t t)
          (copy-directory file-path dir t t t)))
      (quelpa-build--dump new-stamp-info stamp-file)
      (quelpa-file-version file-path type version time-stamp))))

;; --- package-build fork ------------------------------------------

(defcustom quelpa-build-verbose t
  "When non-nil, then print additional progress information."
  :type 'boolean)

(defcustom quelpa-build-stable nil
  "When non-nil, then try to build packages from versions-tagged code."
  :type 'boolean)

(defcustom quelpa-build-timeout-executable
  (let ((prog (or (executable-find "timeout")
                  (executable-find "gtimeout"))))
    (when (and prog
               (string-match-p "^ *-k"
                               (shell-command-to-string (concat prog " --help"))))
      prog))
  "Path to a GNU coreutils \"timeout\" command if available.
This must be a version which supports the \"-k\" option."
  :type '(choice (const nil)
                 (file :must-match t)))

(defcustom quelpa-build-timeout-secs 600
  "Wait this many seconds for external processes to complete.

If an external process takes longer than specified here to
complete, then it is terminated.  This only has an effect
if `quelpa-build-timeout-executable' is non-nil."
  :type 'number)

(defcustom quelpa-build-tar-executable
  (or (executable-find "gtar")
      (executable-find "tar"))
  "Path to a (preferably GNU) tar command.
Certain package names (e.g. \"@\") may not work properly with a BSD tar."
  :type '(choice (const nil)
                 (file :must-match t)))

(defvar quelpa--tar-type nil
  "Type of `quelpa-build-tar-executable'.  Can be `gnu' or `bsd'.
nil means the type is not decided yet.")

(defcustom quelpa-build-explicit-tar-format-p nil
  "If non-nil pass \"--format=gnu\" option to tar command.

Passing the option is necessary on the systems where the default
tar format isn't gnu."
  :type 'boolean)


(defcustom quelpa-build-version-regexp "^[rRvV]?\\(.*\\)$"
  "Default pattern for matching valid version-strings within repository tags.
The string in the capture group should be parsed as valid by `version-to-list'."
  :type 'string)

;;; Internal Variables

(defconst quelpa-build-default-files-spec
  '("*.el" "*.el.in" "dir"
    "*.info" "*.texi" "*.texinfo"
    "doc/dir" "doc/*.info" "doc/*.texi" "doc/*.texinfo"
    (:exclude ".dir-locals.el" "test.el" "tests.el" "*-test.el" "*-tests.el"))
  "Default value for :files attribute in recipes.")

;;; Utilities

(defun quelpa-build--message (format-string &rest args)
  "Behave like `message' if `quelpa-build-verbose' is non-nil.
Otherwise do nothing."
  (when quelpa-build-verbose
    (apply 'message format-string args)))

(defun quelpa-build--slurp-file (file)
  "Return the contents of FILE as a string, or nil if no such file exists."
  (when (file-exists-p file)
    (with-temp-buffer
      (insert-file-contents file)
      (buffer-substring-no-properties (point-min) (point-max)))))

(defun quelpa-build--string-rtrim (str)
  "Remove trailing whitespace from `STR'."
  (replace-regexp-in-string "[ \t\n\r]+$" "" str))

(defun quelpa-build--trim (str &optional chr)
  "Return a copy of STR without any trailing CHR (or space if unspecified)."
  (if (equal (elt str (1- (length str))) (or chr ? ))
      (substring str 0 (1- (length str)))
    str))

;;; Version Handling

(defun quelpa-build--valid-version (str &optional regexp)
  "Apply to STR the REGEXP if defined, \
then pass the string to `version-to-list' and return the result, \
or nil if the version cannot be parsed."
  (when (and regexp (string-match regexp str))
    (setq str (match-string 1 str)))
  (ignore-errors (version-to-list str)))

(defun quelpa-build--parse-time (str)
  "Parse STR as a time, and format as a YYYYMMDD.HHMM string."
  ;; We remove zero-padding the HH portion, as it is lost
  ;; when stored in the archive-contents
  (setq str (substring-no-properties str))
  (let ((time (date-to-time
               (if (string-match "\
^\\([0-9]\\{4\\}\\)/\\([0-9]\\{2\\}\\)/\\([0-9]\\{2\\}\\) \
\\([0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\)$" str)
                   (concat (match-string 1 str) "-" (match-string 2 str) "-"
                           (match-string 3 str) " " (match-string 4 str))
                 str))))
    (concat (format-time-string "%Y%m%d." time)
            (format "%d" (string-to-number (format-time-string "%H%M" time))))))

(defun quelpa-build--find-parse-time (regexp &optional bound)
  "Find REGEXP in current buffer and format as a time-based version string.
An optional second argument BOUND bounds the search; it is a
buffer position. The match found must not end after that
position."
  (and (re-search-backward regexp bound t)
       (quelpa-build--parse-time (match-string-no-properties 1))))

(defun quelpa-build--find-parse-time-newest (regexp &optional bound)
  "Find REGEXP in current buffer and format as a time-based version string.
An optional second argument BOUND bounds the search; it is a
buffer position. The match found must not end after that
position."
  (save-match-data
    (let (cur matches)
      (while (setq cur (quelpa-build--find-parse-time regexp bound))
        (push cur matches))
      (car (nreverse (sort matches 'string<))))))

(defun quelpa-build--find-version-newest (regexp &optional bound)
  "Find the newest version matching REGEXP before point.
An optional second argument BOUND bounds the search; it is a
buffer position. The match found must not before after that
position."
  (let ((tags (split-string
               (buffer-substring-no-properties
                (or bound (point-min)) (point))
               "\n")))
    (setq tags (append
                (mapcar
                 ;; Because the default `version-separator' is ".",
                 ;; version-strings like "1_4_5" will be parsed
                 ;; wrongly as (1 -4 4 -4 5), so we set
                 ;; `version-separator' to "_" below and run again.
                 (lambda (tag)
                   (when (quelpa-build--valid-version tag regexp)
                     (list (quelpa-build--valid-version tag regexp) tag)))
                 tags)
                (mapcar
                 ;; Check for valid versions again, this time using
                 ;; "_" as a separator instead of "." to catch
                 ;; version-strings like "1_4_5".  Since "_" is
                 ;; otherwise treated as a snapshot separator by
                 ;; `version-regexp-alist', we don't have to worry
                 ;; about the incorrect version list above—(1 -4 4 -4
                 ;; 5)—since it will always be treated as older by
                 ;; `version-list-<'.
                 (lambda (tag)
                   (let ((version-separator "_"))
                     (when (quelpa-build--valid-version tag regexp)
                       (list (quelpa-build--valid-version tag regexp) tag))))
                 tags)))
    (setq tags (cl-remove-if nil tags))
    ;; Returns a list like ((0 1) ("v0.1")); the first element is used
    ;; for comparison and for `package-version-join', and the second
    ;; (the original tag) is used by git/hg/etc.
    (car (nreverse (sort tags (lambda (v1 v2) (version-list-< (car v1) (car v2))))))))

;;; Run Process

(defun quelpa-build--run-process (dir command &rest args)
  "In DIR run COMMAND with ARGS.
If DIR is unset, try to run from `quelpa-build-dir'
or variable `temporary-file-directory'.
Output is written to the current buffer."
  (let ((default-directory (file-name-as-directory (or dir
                                                       quelpa-build-dir
                                                       temporary-file-directory)))
        (argv (nconc (unless (eq system-type 'windows-nt)
                       (list "env" "LC_ALL=C"))
                     (if quelpa-build-timeout-executable
                         (nconc (list quelpa-build-timeout-executable
                                      "-k" "60" (number-to-string
                                                 quelpa-build-timeout-secs)
                                      command)
                                args)
                       (cons command args)))))
    (unless (file-directory-p default-directory)
      (error "Can't run process in non-existent directory: %s" default-directory))
    (let ((exit-code (apply 'process-file
                            (car argv) nil (current-buffer) t
                            (cdr argv))))
      (or (zerop exit-code)
          (error "Command '%s' exited with non-zero status %d: %s"
                 argv exit-code (buffer-string))))))

(defun quelpa-build--run-process-match (regexp dir prog &rest args)
  "Run PROG with args and return the first match for REGEXP in its output.
PROG is run in DIR, or if that is nil in `default-directory'."
  (with-temp-buffer
    (apply 'quelpa-build--run-process dir prog args)
    (goto-char (point-min))
    (re-search-forward regexp)
    (match-string-no-properties 1)))

;;; Checkout
;;;; Common

(defun quelpa-build-checkout (package-name config working-dir)
  "Check out source for PACKAGE-NAME with CONFIG under WORKING-DIR.
In turn, this function uses the :fetcher option in the CONFIG to
choose a source-specific fetcher function, which it calls with
the same arguments.

Returns the package version as a string."
  (let ((fetcher (plist-get config :fetcher)))
    (quelpa-build--message "Fetcher: %s" fetcher)
    (unless (eq fetcher 'wiki)
      (quelpa-build--message "Source: %s\n"
                             (or (plist-get config :repo)
                                 (plist-get config :url))))
    (funcall (intern (format "quelpa-build--checkout-%s" fetcher))
             package-name config (file-name-as-directory working-dir))))

(defun quelpa-build--princ-exists (dir)
  "Print a message that the contents of DIR will be updated."
  (quelpa-build--message "Updating %s" dir))

(defun quelpa-build--princ-checkout (repo dir)
  "Print a message that REPO will be checked out into DIR."
  (quelpa-build--message "Cloning %s to %s" repo dir))

;;;; Wiki

(defvar quelpa-build--last-wiki-fetch-time 0
  "The time at which an emacswiki URL was last requested.
This is used to avoid exceeding the rate limit of 1 request per 2
seconds; the server cuts off after 10 requests in 20 seconds.")

(defvar quelpa-build--wiki-min-request-interval 3
  "The shortest permissible interval between successive requests for Emacswiki URLs.")

(defmacro quelpa-build--with-wiki-rate-limit (&rest body)
  "Rate-limit BODY code passed to this macro to match EmacsWiki's rate limiting."
  (let ((elapsed (cl-gensym)))
    `(let ((,elapsed (- (float-time) quelpa-build--last-wiki-fetch-time)))
       (when (< ,elapsed quelpa-build--wiki-min-request-interval)
         (let ((wait (- quelpa-build--wiki-min-request-interval ,elapsed)))
           (quelpa-build--message
            "Waiting %.2f secs before hitting Emacswiki again" wait)
           (sleep-for wait)))
       (unwind-protect
           (progn ,@body)
         (setq quelpa-build--last-wiki-fetch-time (float-time))))))

(require 'mm-decode)
(defvar url-http-response-status)
(defvar url-http-end-of-headers)

(defun quelpa-build--url-copy-file (url newname &optional ok-if-already-exists)
  "Copy URL to NEWNAME.  Both args must be strings.
Returns the http request's header as a string.
Like `url-copy-file', but it produces an error if the http response is not 200.
Signals a `file-already-exists' error if file NEWNAME already exists,
unless a third argument OK-IF-ALREADY-EXISTS is supplied and non-nil.
A number as third arg means request confirmation if NEWNAME already exists."
  (if (and (file-exists-p newname)
           (not ok-if-already-exists))
      (error "Opening output file: File already exists, %s" newname))
  (let ((buffer (url-retrieve-synchronously url))
        (headers nil)
        (handle nil))
    (if (not buffer)
        (error "Opening input file: No such file or directory, %s" url))
    (with-current-buffer buffer
      (unless (= 200 url-http-response-status)
        (error "HTTP error %s fetching %s" url-http-response-status url))
      (setq handle (mm-dissect-buffer t))
      (mail-narrow-to-head)
      (setq headers (buffer-string)))
    (mm-save-part-to-file handle newname)
    (kill-buffer buffer)
    (mm-destroy-parts handle)
    headers))

(defun quelpa-build--grab-wiki-file (filename)
  "Download FILENAME from emacswiki, returning its last-modified time."
  (let ((download-url
         (format "https://www.emacswiki.org/emacs/download/%s" filename))
        headers)
    (quelpa-build--with-wiki-rate-limit
     (setq headers (quelpa-build--url-copy-file download-url filename t)))
    (when (zerop (nth 7 (file-attributes filename)))
      (error "Wiki file %s was empty - has it been removed?" filename))
    (quelpa-build--parse-time
     (with-temp-buffer
       (insert headers)
       (mail-fetch-field "last-modified")))))

(defun quelpa-build--checkout-wiki (name config dir)
  "Checkout package NAME with config CONFIG from the EmacsWiki into DIR."
  (unless quelpa-build-stable
    (with-current-buffer (get-buffer-create "*quelpa-build-checkout*")
      (unless (file-exists-p dir)
        (make-directory dir))
      (let ((files (or (plist-get config :files)
                       (list (format "%s.el" name))))
            (default-directory dir))
        (car (nreverse (sort (mapcar 'quelpa-build--grab-wiki-file files)
                             'string-lessp)))))))

;;;; Darcs

(defun quelpa-build--darcs-repo (dir)
  "Get the current darcs repo for DIR."
  (quelpa-build--run-process-match "Default Remote: \\(.*\\)"
                                   dir "darcs" "show" "repo"))

(defun quelpa-build--checkout-darcs (name config dir)
  "Check package NAME with config CONFIG out of darcs into DIR."
  (let ((repo (plist-get config :url)))
    (with-current-buffer (get-buffer-create "*quelpa-build-checkout*")
      (cond
       ((and (file-exists-p (expand-file-name "_darcs" dir))
             (string-equal (quelpa-build--darcs-repo dir) repo))
        (quelpa-build--princ-exists dir)
        (quelpa-build--run-process dir "darcs" "pull" "--all"))
       (t
        (when (file-exists-p dir)
          (delete-directory dir t))
        (quelpa-build--princ-checkout repo dir)
        (quelpa-build--run-process nil "darcs" "get" repo dir)))
      (if quelpa-build-stable
          (let* ((min-bound (goto-char (point-max)))
                 (tag-version
                  (and (quelpa-build--run-process dir "darcs" "show" "tags")
                       (or (quelpa-build--find-version-newest
                            (or (plist-get config :version-regexp)
                                quelpa-build-version-regexp)
                            min-bound)
                           (error "No valid stable versions found for %s" name)))))
            (quelpa-build--run-process dir "darcs" "obliterate"
                                       "--all" "--from-tag"
                                       (cadr tag-version))
            ;; Return the parsed version as a string
            (package-version-join (car tag-version)))
        (apply 'quelpa-build--run-process
               dir "darcs" "changes" "--max-count" "1"
               (quelpa-build--expand-source-file-list dir config))
        (quelpa-build--find-parse-time "\
\\([a-zA-Z]\\{3\\} [a-zA-Z]\\{3\\} \
\\( \\|[0-9]\\)[0-9] [0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\} \
[A-Za-z]\\{3\\} [0-9]\\{4\\}\\)")))))

;;;; Fossil

(defun quelpa-build--fossil-repo (dir)
  "Get the current fossil repo for DIR."
  (quelpa-build--run-process-match "\\(.*\\)" dir "fossil" "remote-url"))

(defun quelpa-build--checkout-fossil (name config dir)
  "Check package NAME with config CONFIG out of fossil into DIR."
  (unless quelpa-build-stable
    (let ((repo (plist-get config :url)))
      (with-current-buffer (get-buffer-create "*quelpa-build-checkout*")
        (cond
         ((and (or (file-exists-p (expand-file-name ".fslckout" dir))
                   (file-exists-p (expand-file-name "_FOSSIL_" dir)))
               (string-equal (quelpa-build--fossil-repo dir) repo))
          (quelpa-build--princ-exists dir)
          (quelpa-build--run-process dir "fossil" "update"))
         (t
          (when (file-exists-p dir)
            (delete-directory dir t))
          (quelpa-build--princ-checkout repo dir)
          (make-directory dir)
          (quelpa-build--run-process dir "fossil" "clone" repo "repo.fossil")
          (quelpa-build--run-process dir "fossil" "open" "repo.fossil")))
        (quelpa-build--run-process dir "fossil" "timeline" "-n" "1" "-t" "ci")
        (or (quelpa-build--find-parse-time "\
=== \\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} ===\n\
[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\) ")
            (error "No valid timestamps found!"))))))

;;;; Svn

(defun quelpa-build--svn-repo (dir)
  "Get the current svn repo for DIR."
  (quelpa-build--run-process-match "URL: \\(.*\\)" dir "svn" "info"))

(defun quelpa-build--checkout-svn (name config dir)
  "Check package NAME with config CONFIG out of svn into DIR."
  (unless quelpa-build-stable
    (with-current-buffer (get-buffer-create "*quelpa-build-checkout*")
      (let ((repo (quelpa-build--trim (plist-get config :url) ?/))
            (bound (goto-char (point-max))))
        (cond
         ((and (file-exists-p (expand-file-name ".svn" dir))
               (string-equal (quelpa-build--svn-repo dir) repo))
          (quelpa-build--princ-exists dir)
          (quelpa-build--run-process dir "svn" "up"))
         (t
          (when (file-exists-p dir)
            (delete-directory dir t))
          (quelpa-build--princ-checkout repo dir)
          (quelpa-build--run-process nil "svn" "checkout" repo dir)))
        (apply 'quelpa-build--run-process dir "svn" "info"
               (quelpa-build--expand-source-file-list dir config))
        (or (quelpa-build--find-parse-time-newest "\
Last Changed Date: \\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} \
[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\( [+-][0-9]\\{4\\}\\)?\\)"
                                                  bound)
            (error "No valid timestamps found!"))))))

;;;; Cvs

(defun quelpa-build--cvs-repo (dir)
  "Get the current CVS root and repository for DIR.

Return a cons cell whose `car' is the root and whose `cdr' is the repository."
  (apply 'cons
         (mapcar (lambda (file)
                   (quelpa-build--string-rtrim
                    (quelpa-build--slurp-file (expand-file-name file dir))))
                 '("CVS/Root" "CVS/Repository"))))

(defun quelpa-build--checkout-cvs (name config dir)
  "Check package NAME with config CONFIG out of cvs into DIR."
  (unless quelpa-build-stable
    (with-current-buffer (get-buffer-create "*quelpa-build-checkout*")
      (let ((root (quelpa-build--trim (plist-get config :url) ?/))
            (repo (or (plist-get config :module) (symbol-name name)))
            (bound (goto-char (point-max)))
            latest)
        (cond
         ((and (file-exists-p (expand-file-name "CVS" dir))
               (equal (quelpa-build--cvs-repo dir) (cons root repo)))
          (quelpa-build--princ-exists dir)
          (quelpa-build--run-process dir "cvs" "update" "-dP"))
         (t
          (when (file-exists-p dir)
            (delete-directory dir t))
          (quelpa-build--princ-checkout (format "%s from %s" repo root) dir)
          ;; CVS insists on relative paths as target directory for checkout (for
          ;; whatever reason), and puts "CVS" directories into every subdirectory
          ;; of the current working directory given in the target path. To get CVS
          ;; to just write to DIR, we need to execute CVS from the parent
          ;; directory of DIR, and specific DIR as relative path.  Hence all the
          ;; following mucking around with paths.  CVS is really horrid.
          (let ((dir (directory-file-name dir)))
            (quelpa-build--run-process (file-name-directory dir)
                                       "env" "TZ=UTC" "cvs" "-z3"
                                       "-d" root "checkout"
                                       "-d" (file-name-nondirectory dir)
                                       repo))))
        (apply 'quelpa-build--run-process dir "cvs" "log"
               (quelpa-build--expand-source-file-list dir config))

        ;; `cvs log` does not provide a way to view the previous N
        ;; revisions, so instead of parsing the entire log we examine
        ;; the Entries file, which looks like this:
        ;;
        ;; /.cvsignore/1.2/Thu Sep  1 12:42:02 2005//
        ;; /CHANGES/1.1/Tue Oct  4 11:47:54 2005//
        ;; /GNUmakefile/1.8/Tue Oct  4 11:47:54 2005//
        ;; /Makefile/1.14/Tue Oct  4 11:47:54 2005//
        ;;
        (insert-file-contents (concat dir "/CVS/Entries"))
        (setq latest
              (car
               (sort
                (split-string (buffer-substring-no-properties (point) (point-max)) "\n")
                (lambda (x y)
                  (when (string-match "^\\/[^\\/]*\\/[^\\/]*\\/\\([^\\/]*\\)\\/\\/$" x)
                    (setq x (quelpa-build--parse-time (match-string 1 x))))
                  (when (string-match "^\\/[^\\/]*\\/[^\\/]*\\/\\([^\\/]*\\)\\/\\/$" y)
                    (setq y (quelpa-build--parse-time (match-string 1 y))))
                  (version-list-<= (quelpa-build--valid-version y)
                                   (quelpa-build--valid-version x))))))
        (when (string-match "^\\/[^\\/]*\\/[^\\/]*\\/\\([^\\/]*\\)\\/\\/$" latest)
          (setq latest (match-string 1 latest)))
        (or (quelpa-build--parse-time latest)
            (error "No valid timestamps found!"))))))

;;;; Git

(defun quelpa-build--git-repo (dir remote)
  "Get the current git repo for DIR from REMOTE."
  (quelpa-build--run-process-match
   "Fetch URL: \\(.*\\)" dir "git" "remote" "show" "-n" remote))

(defvar quelpa--git-version :uninitialized)

(defun quelpa-build--checkout-git (name config dir)
  "Check package NAME with config CONFIG out of git into DIR."
  (let* ((version-regexp-alist `(,@version-regexp-alist ("^[-._+ ]?.*$" . 0)))
         (git-version (or (when (not (eq quelpa--git-version :uninitialized))
                            quelpa--git-version)
                          (setq quelpa--git-version (version-to-list
                                                     (quelpa-build--run-process-match
                                                      "git version \\(.*\\)"
                                                      nil "git" "version")))))
         (repo (plist-get config :url))
         (remote (or (plist-get config :remote) "origin"))
         (commit (or (plist-get config :commit)
                     (when-let ((branch (plist-get config :branch)))
                       (concat remote "/" branch))))
         (depth (or (plist-get config :depth) quelpa-git-clone-depth))
         (partial (and (or (plist-get config :partial) quelpa-git-clone-partial)
                       (version-list-<= '(2 20) git-version)))
         (force (plist-get config :force))
         (use-current-ref (plist-get config :use-current-ref)))
    (when (string-match (rx bos "file://" (group (1+ anything))) repo)
      ;; Expand local file:// URLs
      (setq repo (expand-file-name (match-string 1 repo))))
    (setq quelpa--override-version-check use-current-ref)
    (with-current-buffer (get-buffer-create "*quelpa-build-checkout*")
      (goto-char (point-max))
      (cond
       ((and (file-exists-p (expand-file-name ".git" dir))
             (string-equal (quelpa-build--git-repo dir remote) repo))
        (quelpa-build--princ-exists dir)
        (quelpa-build--run-process dir "git" "fetch" "--tags" remote))
       (t
        (when (file-exists-p dir)
          (delete-directory dir t))
        (quelpa-build--princ-checkout repo dir)
        (apply #'quelpa-build--run-process
               (append
                `(nil "git" "clone" ,repo ,dir)
                `("--origin" ,remote)
                (pcase partial
                  (:blobless `("--filter=blob:none"))
                  (:treeless `("--filter=tree:0")))
                (when (and depth (not (plist-get config :commit)))
                  `("--depth" ,(int-to-string depth)
                    "--no-single-branch"))
                (when-let ((branch (plist-get config :branch)))
                  `("--branch" ,branch))))))
      (if quelpa-build-stable
          (let* ((min-bound (goto-char (point-max)))
                 (tag-version
                  (and (quelpa-build--run-process dir "git" "tag")
                       (or (quelpa-build--find-version-newest
                            (or (plist-get config :version-regexp)
                                quelpa-build-version-regexp)
                            min-bound)
                           (error "No valid stable versions found for %s" name)))))
            ;; Using reset --hard here to comply with what's used for
            ;; unstable, but maybe this should be a checkout?
            (unless use-current-ref
              (quelpa-build--update-git-to-ref
               dir (concat "tags/" (cadr tag-version))
               force))
            ;; Return the parsed version as a string
            (package-version-join (car tag-version)))
        (unless use-current-ref
          (quelpa-build--update-git-to-ref
           dir (or commit (concat remote "/" (quelpa-build--git-head-branch dir)))
           force))
        (apply 'quelpa-build--run-process
               dir "git" "log" "--first-parent" "-n1" "--pretty=format:'\%ci'"
               (quelpa-build--expand-source-file-list dir config))
        (quelpa-build--find-parse-time "\
\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} \
[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\( [+-][0-9]\\{4\\}\\)?\\)")))))

(defun quelpa-build--git-head-branch (dir)
  "Get the current git repo for DIR."
  (or (ignore-errors
        (quelpa-build--run-process-match
         "HEAD branch: \\(.*\\)" dir "git" "remote" "show" "origin"))
      "master"))

(defun quelpa-build--git-head-sha (dir)
  "Get the current head SHA for DIR."
  (ignore-errors
    (quelpa-build--run-process-match
     "\\(.*\\)" dir "git" "rev-parse" "HEAD")))

(defun quelpa-build--update-git-to-ref (dir ref &optional force)
  "Update the git repo in DIR so that HEAD is REF.
This will perform an checkout or a reset if FORCE."
  (condition-case nil
      (quelpa-build--run-process dir "git" "cat-file" "-e" ref)
    (error
     ;; unshallow if needed
     (quelpa-build--run-process dir "git" "fetch" "--unshallow" "--tags")))
  (if force
      (quelpa-build--run-process dir "git" "reset" "--hard" ref)
    (with-demoted-errors "Error: %s"
      (quelpa-build--run-process dir "git" "checkout" ref)))
  (quelpa-build--run-process dir "git" "submodule" "sync" "--recursive")
  (quelpa-build--run-process dir "git" "submodule" "update" "--init" "--recursive"))

(defun quelpa-build--checkout-github (name config dir)
  "Check package NAME with config CONFIG out of github into DIR."
  (let ((url (format "https://github.com/%s.git" (plist-get config :repo))))
    (quelpa-build--checkout-git name (plist-put (copy-sequence config) :url url) dir)))

(defun quelpa-build--checkout-github-ssh (name config dir)
  "Check package NAME with config CONFIG out of github into DIR."
  (let ((url (format "git@github.com:%s.git" (plist-get config :repo))))
    (quelpa-build--checkout-git name (plist-put (copy-sequence config) :url url) dir)))

(defun quelpa-build--checkout-gitlab (name config dir)
  "Check package NAME with config CONFIG out of gitlab into DIR."
  (let ((url (format "https://gitlab.com/%s.git" (plist-get config :repo))))
    (quelpa-build--checkout-git name (plist-put (copy-sequence config) :url url) dir)))

;;;; Bzr

(defun quelpa-build--bzr-repo (dir)
  "Get the current bzr repo for DIR."
  (quelpa-build--run-process-match "parent branch: \\(.*\\)" dir "bzr" "info"))

(defun quelpa-build--checkout-bzr (name config dir)
  "Check package NAME with config CONFIG out of bzr into DIR."
  (let ((repo (quelpa-build--run-process-match
               "\\(?:branch root\\|repository branch\\): \\(.*\\)"
               nil "bzr" "info" (plist-get config :url))))
    (with-current-buffer (get-buffer-create "*quelpa-build-checkout*")
      (goto-char (point-max))
      (cond
       ((and (file-exists-p (expand-file-name ".bzr" dir))
             (string-equal (quelpa-build--bzr-repo dir) repo))
        (quelpa-build--princ-exists dir)
        (quelpa-build--run-process dir "bzr" "merge" "--force"))
       (t
        (when (file-exists-p dir)
          (delete-directory dir t))
        (quelpa-build--princ-checkout repo dir)
        (quelpa-build--run-process nil "bzr" "branch" repo dir)))
      (if quelpa-build-stable
          (let ((bound (goto-char (point-max)))
                (regexp (or (plist-get config :version-regexp)
                            quelpa-build-version-regexp))
                tag-version)
            (quelpa-build--run-process dir "bzr" "tags")
            (goto-char bound)
            (ignore-errors (while (re-search-forward "\\ +.*")
                             (replace-match "")))
            (setq tag-version
                  (or (quelpa-build--find-version-newest regexp bound)
                      (error "No valid stable versions found for %s" name)))
            (quelpa-build--run-process dir
                                       "bzr" "revert" "-r"
                                       (concat "tag:" (cadr tag-version)))
            ;; Return the parsed version as a string
            (package-version-join (car tag-version)))
        (apply 'quelpa-build--run-process dir "bzr" "log" "-l1"
               (quelpa-build--expand-source-file-list dir config))
        (quelpa-build--find-parse-time "\
\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} \
[0-9]\\{2\\}:[0-9]\\{2\\}:[0-9]\\{2\\}\\( [+-][0-9]\\{4\\}\\)?\\)")))))

;;;; Hg

(defun quelpa-build--hg-repo (dir)
  "Get the current hg repo for DIR."
  (quelpa-build--run-process-match "default = \\(.*\\)" dir "hg" "paths"))

(defun quelpa-build--checkout-hg (name config dir)
  "Check package NAME with config CONFIG out of hg into DIR."
  (let ((repo (plist-get config :url)))
    (with-current-buffer (get-buffer-create "*quelpa-build-checkout*")
      (goto-char (point-max))
      (cond
       ((and (file-exists-p (expand-file-name ".hg" dir))
             (string-equal (quelpa-build--hg-repo dir) repo))
        (quelpa-build--princ-exists dir)
        (quelpa-build--run-process dir "hg" "pull")
        (quelpa-build--run-process dir "hg" "update"))
       (t
        (when (file-exists-p dir)
          (delete-directory dir t))
        (quelpa-build--princ-checkout repo dir)
        (quelpa-build--run-process nil "hg" "clone" repo dir)))
      (if quelpa-build-stable
          (let ((min-bound (goto-char (point-max)))
                (regexp (or (plist-get config :version-regexp)
                            quelpa-build-version-regexp))
                tag-version)
            (quelpa-build--run-process dir "hg" "tags")
            ;; The output of `hg tags` shows the ref of the tag as well
            ;; as the tag itself, e.g.:
            ;;
            ;; tip                             1696:73ad80e8fea1
            ;; 1.2.8                           1691:464af57fd2b7
            ;;
            ;; So here we remove that second column before passing the
            ;; buffer contents to `quelpa-build--find-version-newest'.
            ;; This isn't strictly necessary for Mercurial since the
            ;; colon in "1691:464af57fd2b7" means that won't be parsed
            ;; as a valid version-string, but it's an example of how to
            ;; do it in case it's necessary elsewhere.
            (goto-char min-bound)
            (ignore-errors (while (re-search-forward "\\ +.*")
                             (replace-match "")))
            (setq tag-version
                  (or (quelpa-build--find-version-newest regexp min-bound)
                      (error "No valid stable versions found for %s" name)))
            (quelpa-build--run-process dir "hg" "update" (cadr tag-version))
            ;; Return the parsed version as a string
            (package-version-join (car tag-version)))
        (apply 'quelpa-build--run-process
               dir "hg" "log" "--style" "compact" "-l1"
               (quelpa-build--expand-source-file-list dir config))
        (quelpa-build--find-parse-time "\
\\([0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\} \
[0-9]\\{2\\}:[0-9]\\{2\\}\\( [+-][0-9]\\{4\\}\\)?\\)")))))

(defun quelpa-build--checkout-bitbucket (name config dir)
  "Check package NAME with config CONFIG out of bitbucket into DIR."
  (let ((url (format "https://bitbucket.com/%s" (plist-get config :repo))))
    (quelpa-build--checkout-hg name (plist-put (copy-sequence config) :url url) dir)))

;;; Utilities

(defun quelpa-build--dump (data file &optional pretty-print)
  "Write DATA to FILE as a Lisp sexp.
Optionally PRETTY-PRINT the data."
  (with-temp-file file
    (quelpa-build--message "File: %s" file)
    (if pretty-print
        (pp data (current-buffer))
      (print data (current-buffer)))))

(defun quelpa-build--write-pkg-file (pkg-file pkg-info)
  "Write PKG-FILE containing PKG-INFO."
  (with-temp-file pkg-file
    (pp
     `(define-package
        ,(aref pkg-info 0)
        ,(aref pkg-info 3)
        ,(aref pkg-info 2)
        ',(mapcar
           (lambda (elt)
             (list (car elt)
                   (package-version-join (cadr elt))))
           (aref pkg-info 1))
        ;; Append our extra information
        ,@(cl-mapcan (lambda (entry)
                       (let ((value (cdr entry)))
                         (when (or (symbolp value) (listp value))
                           ;; We must quote lists and symbols,
                           ;; because Emacs 24.3 and earlier evaluate
                           ;; the package information, which would
                           ;; break for unquoted symbols or lists
                           (setq value (list 'quote value)))
                         (list (car entry) value)))
                     (when (> (length pkg-info) 4)
                       (aref pkg-info 4))))
     (current-buffer))
    (princ ";; Local Variables:\n;; no-byte-compile: t\n;; End:\n"
           (current-buffer))))

(defun quelpa-build--read-from-file (file)
  "Read and return the Lisp data stored in FILE, or nil if no such file exists."
  (when (file-exists-p file)
    (car (read-from-string (quelpa-build--slurp-file file)))))

(defun quelpa--tar-type ()
  "Return `bsd' or `gnu' depending on type of Tar executable.
Tests and sets variable `quelpa--tar-type' if not already set."
  (or quelpa--tar-type
      (when (and quelpa-build-tar-executable
                 (file-executable-p quelpa-build-tar-executable))
        (setq quelpa--tar-type
              (let ((v (shell-command-to-string
                        (format "%s --version" quelpa-build-tar-executable))))
                (cond ((string-match-p "bsdtar" v) 'bsd)
                      ((string-match-p "GNU tar" v) 'gnu)
                      (t 'gnu)))))))

(defun quelpa-build--create-tar (file dir &optional files)
  "Create a tar FILE containing the contents of DIR, or just FILES if non-nil."
  (when (and (eq (quelpa--tar-type) 'gnu)
             (eq system-type 'windows-nt))
    (setq file (replace-regexp-in-string "^\\([a-z]\\):" "/\\1" file)))
  (apply 'process-file
         quelpa-build-tar-executable nil
         (get-buffer-create "*quelpa-build-checkout*")
         nil "-cvf"
         file
         "--exclude=.svn"
         "--exclude=CVS"
         "--exclude=.git"
         "--exclude=_darcs"
         "--exclude=.fslckout"
         "--exclude=_FOSSIL_"
         "--exclude=.bzr"
         "--exclude=.hg"
         (append (and quelpa-build-explicit-tar-format-p '("--format=gnu"))
                 (or (mapcar (lambda (fn) (concat dir "/" fn)) files) (list dir)))))

(defun quelpa-build--find-package-commentary (file-path)
  "Get commentary section from FILE-PATH."
  (when (file-exists-p file-path)
    (with-temp-buffer
      (insert-file-contents file-path)
      (lm-commentary))))

(defun quelpa-build--write-pkg-readme (target-dir commentary file-name)
  "In TARGET-DIR, write COMMENTARY to a -readme.txt file prefixed with FILE-NAME."
  (when commentary
    (with-temp-buffer
      (insert commentary)
      ;; Adapted from `describe-package-1'.
      (goto-char (point-min))
      (save-excursion
        (when (re-search-forward "^;;; Commentary:\n" nil t)
          (replace-match ""))
        (while (re-search-forward "^\\(;+ ?\\)" nil t)
          (replace-match ""))
        (goto-char (point-min))
        (when (re-search-forward "\\`\\( *\n\\)+" nil t)
          (replace-match "")))
      (delete-trailing-whitespace)
      (let ((coding-system-for-write buffer-file-coding-system))
        (write-region nil nil
                      (quelpa-build--readme-file-name target-dir file-name))))))

(defun quelpa-build--readme-file-name (target-dir file-name)
  "Name of the readme file in TARGET-DIR for the package FILE-NAME."
  (expand-file-name (concat file-name "-readme.txt")
                    target-dir))

(defun quelpa-build--update-or-insert-version (version)
  "Ensure current buffer has a \"Package-Version: VERSION\" header."
  (goto-char (point-min))
  (if (let ((case-fold-search t))
        (re-search-forward "^;+* *Package-Version *: *" nil t))
      (progn
        (move-beginning-of-line nil)
        (search-forward "V" nil t)
        (backward-char)
        (insert "X-Original-")
        (move-beginning-of-line nil))
    ;; Put the new header in a sensible place if we can
    (re-search-forward "^;+* *\\(Version\\|Package-Requires\\|Keywords\\|URL\\) *:"
                       nil t)
    (forward-line))
  (insert (format ";; Package-Version: %s" version))
  (newline))

(defun quelpa-build--ensure-ends-here-line (file-path)
  "Add a 'FILE-PATH ends here' trailing line if missing."
  (save-excursion
    (goto-char (point-min))
    (let ((trailer (concat ";;; "
                           (file-name-nondirectory file-path)
                           " ends here")))
      (unless (search-forward trailer nil t)
        (goto-char (point-max))
        (newline)
        (insert trailer)
        (newline)))))

(defun quelpa-build--get-package-info (file-path)
  "Get a vector of package info from the docstrings in FILE-PATH."
  (when (file-exists-p file-path)
    (ignore-errors
      (with-temp-buffer
        (insert-file-contents file-path)
        ;; next few lines are a hack for some packages that aren't
        ;; commented properly.
        (quelpa-build--update-or-insert-version "0")
        (quelpa-build--ensure-ends-here-line file-path)
        (cl-flet ((package-strip-rcs-id (str) "0"))
          (quelpa-build--package-buffer-info-vec))))))

(defun quelpa-build--get-pkg-file-info (file-path)
  "Get a vector of package info from \"-pkg.el\" file FILE-PATH."
  (when (file-exists-p file-path)
    (let ((package-def (quelpa-build--read-from-file file-path)))
      (if (eq 'define-package (car package-def))
          (let* ((pkgfile-info (cdr package-def))
                 (descr (nth 2 pkgfile-info))
                 (rest-plist (cl-subseq pkgfile-info (min 4 (length pkgfile-info))))
                 (extras (let (alist)
                           (while rest-plist
                             (unless (memq (car rest-plist) '(:kind :archive))
                               (when-let ((value (cadr rest-plist)))
                                 (push (cons (car rest-plist)
                                             (if (eq (car-safe value) 'quote)
                                                 (cadr value)
                                               value))
                                       alist)))
                             (setq rest-plist (cddr rest-plist)))
                           alist)))
            (when (string-match "[\r\n]" descr)
              (error "Illegal multi-line package description in %s" file-path))
            (vector
             (nth 0 pkgfile-info)
             (mapcar
              (lambda (elt)
                (unless (symbolp (car elt))
                  (error "Invalid package name in dependency: %S" (car elt)))
                (list (car elt) (version-to-list (cadr elt))))
              (eval (nth 3 pkgfile-info)))
             descr
             (nth 1 pkgfile-info)
             extras))
        (error "No define-package found in %s" file-path)))))

(defun quelpa-build--merge-package-info (pkg-info name version)
  "Return a version of PKG-INFO updated with NAME, VERSION and info from CONFIG.
If PKG-INFO is nil, an empty one is created."
  (let ((merged (or (copy-sequence pkg-info)
                    (vector name nil "No description available." version))))
    (aset merged 0 name)
    (aset merged 3 version)
    merged))

(defun quelpa-build--archive-entry (pkg-info type)
  "Return the archive-contents cons cell for PKG-INFO and TYPE."
  (let ((name (intern (aref pkg-info 0)))
        (requires (aref pkg-info 1))
        (desc (or (aref pkg-info 2) "No description available."))
        (version (aref pkg-info 3))
        (extras (and (> (length pkg-info) 4)
                     (aref pkg-info 4))))
    (cons name
          (vector (version-to-list version)
                  requires
                  desc
                  type
                  extras))))

;;; Recipes

(defun quelpa-build-expand-file-specs (dir specs &optional subdir allow-empty)
  "In DIR, expand SPECS, optionally under SUBDIR.
The result is a list of (SOURCE . DEST), where SOURCE is a source
file path and DEST is the relative path to which it should be copied.

If the resulting list is empty, an error will be reported.  Pass t
for ALLOW-EMPTY to prevent this error."
  (let ((default-directory dir)
        (prefix (if subdir (format "%s/" subdir) ""))
        (lst))
    (dolist (entry specs lst)
      (setq lst
            (if (consp entry)
                (if (eq :exclude (car entry))
                    (cl-nset-difference lst
                                        (quelpa-build-expand-file-specs
                                         dir (cdr entry) nil t)
                                        :key 'car
                                        :test 'equal)
                  (nconc lst
                         (quelpa-build-expand-file-specs
                          dir
                          (cdr entry)
                          (concat prefix (car entry))
                          t)))
              (nconc
               lst (mapcar (lambda (f)
                             (let ((destname)))
                             (cons f
                                   (concat prefix
                                           (replace-regexp-in-string
                                            "\\.in\\'"
                                            ""
                                            (file-name-nondirectory f)))))
                           (file-expand-wildcards entry))))))
    (when (and (null lst) (not allow-empty))
      (error "No matching file(s) found in %s: %s" dir specs))
    lst))

(defun quelpa-build--config-file-list (config)
  "Get the :files spec from CONFIG, or return `quelpa-build-default-files-spec'."
  (let ((file-list (plist-get config :files)))
    (cond
     ((null file-list)
      quelpa-build-default-files-spec)
     ((eq :defaults (car file-list))
      (append quelpa-build-default-files-spec (cdr file-list)))
     (t
      file-list))))

(defun quelpa-build--expand-source-file-list (dir config)
  "Shorthand way to expand paths in DIR for source files listed in CONFIG."
  (mapcar 'car
          (quelpa-build-expand-file-specs
           dir (quelpa-build--config-file-list config))))

(defun quelpa-build--generate-info-files (files source-dir target-dir)
  "Create .info files from any .texi files listed in FILES.

The source and destination file paths are expanded in SOURCE-DIR
and TARGET-DIR respectively.

Any of the original .texi(nfo) files found in TARGET-DIR are
deleted."
  (dolist (spec files)
    (let* ((source-file (car spec))
           (source-path (expand-file-name source-file source-dir))
           (dest-file (cdr spec))
           (info-path (expand-file-name
                       (concat (file-name-sans-extension dest-file) ".info")
                       target-dir)))
      (when (string-match ".texi\\(nfo\\)?$" source-file)
        (when (not (file-exists-p info-path))
          (with-current-buffer (get-buffer-create "*quelpa-build-info*")
            (ignore-errors
              (quelpa-build--run-process
               (file-name-directory source-path)
               "makeinfo"
               source-path
               "-o"
               info-path)
              (quelpa-build--message "Created %s" info-path))))
        (quelpa-build--message "Removing %s"
                               (expand-file-name dest-file target-dir))
        (delete-file (expand-file-name dest-file target-dir))))))

;;; Info Manuals

(defun quelpa-build--generate-dir-file (files target-dir)
  "Create dir file from any .info files listed in FILES in TARGET-DIR."
  (dolist (spec files)
    (let* ((source-file (car spec))
           (dest-file (cdr spec))
           (info-path (expand-file-name
                       (concat (file-name-sans-extension dest-file) ".info")
                       target-dir)))
      (when (and (or (string-match ".info$" source-file)
                     (string-match ".texi\\(nfo\\)?$" source-file))
                 (file-exists-p info-path))
        (with-current-buffer (get-buffer-create "*quelpa-build-info*")
          (ignore-errors
            (quelpa-build--run-process
             nil
             "install-info"
             (concat "--dir=" (expand-file-name "dir" target-dir))
             info-path)))))))

;;; Utilities

(defun quelpa-build--copy-package-files (files source-dir target-dir)
  "Copy FILES from SOURCE-DIR to TARGET-DIR.
FILES is a list of (SOURCE . DEST) relative filepath pairs."
  (cl-loop for (source-file . dest-file) in files
           do (quelpa-build--copy-file
               (expand-file-name source-file source-dir)
               (expand-file-name dest-file target-dir))))

(defun quelpa-build--copy-file (file newname)
  "Copy FILE to NEWNAME and create parent directories for NEWNAME if they don't exist."
  (let ((newdir (file-name-directory newname)))
    (unless (file-exists-p newdir)
      (make-directory newdir t)))
  (cond
   ((file-regular-p file)
    (quelpa-build--message "%s -> %s" file newname)
    (copy-file file newname))
   ((file-directory-p file)
    (quelpa-build--message "%s => %s" file newname)
    (copy-directory file newname))))

(defun quelpa-build--find-source-file (target files)
  "Search for source of TARGET in FILES."
  (car (rassoc target files)))

(defun quelpa-build--package-buffer-info-vec ()
  "Return a vector of package info.
`package-buffer-info' returns a vector in older Emacs versions,
and a cl struct in Emacs HEAD.  This wrapper normalises the results."
  (let ((desc (package-buffer-info))
        (keywords (lm-keywords-list)))
    (if (fboundp 'package-desc-create)
        (let ((extras (package-desc-extras desc)))
          (when (and keywords (not (assq :keywords extras)))
            ;; Add keywords to package properties, if not already present
            (push (cons :keywords keywords) extras))
          (vector (package-desc-name desc)
                  (package-desc-reqs desc)
                  (package-desc-summary desc)
                  (package-desc-version desc)
                  extras))
      (let ((homepage (lm-homepage))
            extras)
        (when keywords (push (cons :keywords keywords) extras))
        (when homepage (push (cons :url homepage) extras))
        (vector  (aref desc 0)
                 (aref desc 1)
                 (aref desc 2)
                 (aref desc 3)
                 extras)))))

;;; Building

;;;###autoload
(defun quelpa-build-package (package-name version file-specs source-dir target-dir)
  "Create PACKAGE-NAME with VERSION.

The information in FILE-SPECS is used to gather files from
SOURCE-DIR.

The resulting package will be stored as a .el or .tar file in
TARGET-DIR, depending on whether there are multiple files.

Argument FILE-SPECS is a list of specs for source files, which
should be relative to SOURCE-DIR.  The specs can be wildcards,
and optionally specify different target paths.  They extended
syntax is currently only documented in the MELPA README.  You can
simply pass `quelpa-build-default-files-spec' in most cases.

Returns the archive entry for the package."
  (when (symbolp package-name)
    (setq package-name (symbol-name package-name)))
  (let ((files (quelpa-build-expand-file-specs source-dir file-specs)))
    (unless (equal file-specs quelpa-build-default-files-spec)
      (when (equal files (quelpa-build-expand-file-specs
                          source-dir quelpa-build-default-files-spec nil t))
        (quelpa-build--message "Note: %s :files spec is equivalent to the default."
                               package-name)))
    (cond
     ((not version)
      (error "Unable to check out repository for %s" package-name))
     ((= 1 (length files))
      (quelpa-build--build-single-file-package
       package-name version (caar files) source-dir target-dir))
     ((< 1 (length  files))
      (quelpa-build--build-multi-file-package
       package-name version files source-dir target-dir))
     (t (error "Unable to find files matching recipe patterns")))))

(defun quelpa-build--build-single-file-package
    (package-name version file source-dir target-dir)
  (let* ((pkg-source (expand-file-name file source-dir))
         (pkg-target (expand-file-name
                      (concat package-name "-" version ".el")
                      target-dir))
         (pkg-info (quelpa-build--merge-package-info
                    (quelpa-build--get-package-info pkg-source)
                    package-name
                    version)))
    (unless (string-equal (downcase (concat package-name ".el"))
                          (downcase (file-name-nondirectory pkg-source)))
      (error "Single file %s does not match package name %s"
             (file-name-nondirectory pkg-source) package-name))
    (if (file-exists-p pkg-target)
        (quelpa-build--message "Skipping rebuild of %s" pkg-target)
      (copy-file pkg-source pkg-target)
      (let ((enable-local-variables nil)
            (make-backup-files nil))
        (with-temp-buffer
          (insert-file-contents pkg-target)
          (quelpa-build--update-or-insert-version version)
          (quelpa-build--ensure-ends-here-line pkg-source)
          (write-file pkg-target nil)
          (condition-case err
              (quelpa-build--package-buffer-info-vec)
            (error
             (quelpa-build--message "Warning: %S" err)))))

      (quelpa-build--write-pkg-readme
       target-dir
       (quelpa-build--find-package-commentary pkg-source)
       package-name))
    (quelpa-build--archive-entry pkg-info 'single)))

(defun quelpa-build--build-multi-file-package
    (package-name version files source-dir target-dir)
  (let ((tmp-dir (file-name-as-directory (make-temp-file package-name t))))
    (unwind-protect
        (let* ((pkg-dir-name (concat package-name "-" version))
               (pkg-tmp-dir (expand-file-name pkg-dir-name tmp-dir))
               (pkg-file (concat package-name "-pkg.el"))
               (pkg-file-source (or (quelpa-build--find-source-file pkg-file files)
                                    pkg-file))
               (file-source (concat package-name ".el"))
               (pkg-source (or (quelpa-build--find-source-file file-source files)
                               file-source))
               (pkg-info (quelpa-build--merge-package-info
                          (let ((default-directory source-dir))
                            (or (quelpa-build--get-pkg-file-info pkg-file-source)
                                ;; some packages (like magit) provide name-pkg.el.in
                                (quelpa-build--get-pkg-file-info
                                 (expand-file-name (concat pkg-file ".in")
                                                   (file-name-directory pkg-source)))
                                (quelpa-build--get-package-info pkg-source)))
                          package-name
                          version)))
          (quelpa-build--copy-package-files files source-dir pkg-tmp-dir)
          (quelpa-build--write-pkg-file (expand-file-name
                                         pkg-file
                                         (file-name-as-directory pkg-tmp-dir))
                                        pkg-info)

          (quelpa-build--generate-info-files files source-dir pkg-tmp-dir)
          (quelpa-build--generate-dir-file files pkg-tmp-dir)

          (let ((default-directory tmp-dir))
            (quelpa-build--create-tar
             (expand-file-name (concat package-name "-" version ".tar")
                               target-dir)
             pkg-dir-name))

          (let ((default-directory source-dir))
            (quelpa-build--write-pkg-readme
             target-dir
             (quelpa-build--find-package-commentary pkg-source)
             package-name))
          (quelpa-build--archive-entry pkg-info 'tar))
      (delete-directory tmp-dir t nil))))

(defun quelpa-build--checkout-file (name config dir)
  "Build according to a PATH with config CONFIG into DIR as NAME.
Generic local file handler for package-build.el.

Handles the following cases:

local file:

Installs a single-file package from a local file.  Use the :path
attribute with a PATH like \"/path/to/file.el\".

local directory:

Installs a multi-file package from a local directory.  Use
the :path attribute with a PATH like \"/path/to/dir\"."
  (quelpa-check-hash name config (expand-file-name (plist-get config :path)) dir))

(defun quelpa-build--checkout-url (name config dir)
  "Build according to an URL with config CONFIG into DIR as NAME.
Generic URL handler for package-build.el.

Handles the following cases:

local file:

Installs a single-file package from a local file.  Use the :url
attribute with an URL like \"file:///path/to/file.el\".

remote file:

Installs a single-file package from a remote file.  Use the :url
attribute with an URL like \"http://domain.tld/path/to/file.el\"."
  (let* ((url (plist-get config :url))
         (remote-file-name (file-name-nondirectory
                            (url-filename (url-generic-parse-url url))))
         (local-path (expand-file-name remote-file-name dir))
         (mm-attachment-file-modes (default-file-modes)))
    (unless (string= (file-name-extension url) "el")
      (error "<%s> does not end in .el" url))
    (unless (file-directory-p dir)
      (make-directory dir))
    (url-copy-file url local-path t)
    (quelpa-check-hash name config local-path dir 'url)))

;; --- helpers ---------------------------------------------------------------

(defun quelpa-message (wait format-string &rest args)
  "Log a message with FORMAT-STRING and ARGS when `quelpa-verbose' is non-nil.
If WAIT is nil don't wait after showing the message. If it is a
number, wait so many seconds. If WAIT is t wait the default time.
Return t in each case."
  (when quelpa-verbose
    (message "Quelpa: %s" (apply 'format format-string args))
    (when (or (not noninteractive) wait) ; no wait if emacs is noninteractive
      (sit-for (or (and (numberp wait) wait) 1.5) t)))
  t)

(defun quelpa-read-cache ()
  "Read from `quelpa-persistent-cache-file' in `quelpa-cache'."
  (when (and quelpa-persistent-cache-p
             (file-exists-p quelpa-persistent-cache-file))
    (with-temp-buffer
      (insert-file-contents-literally quelpa-persistent-cache-file)
      (setq quelpa-cache
            (read (buffer-substring-no-properties (point-min) (point-max)))))))

(defun quelpa-save-cache ()
  "Write `quelpa-cache' to `quelpa-persistent-cache-file'."
  (when quelpa-persistent-cache-p
    (let (print-level print-length)
      (with-temp-file quelpa-persistent-cache-file
        (insert (prin1-to-string quelpa-cache))))))

(defun quelpa-update-cache (cache-item)
  "Update `quelpa-cache' with new CACHE-ITEM."
  ;; try removing existing recipes by name
  (setq quelpa-cache (cl-remove (car cache-item)
                                quelpa-cache :key #'car))
  (push cache-item quelpa-cache)
  (setq quelpa-cache
        (cl-sort quelpa-cache #'string<
                 :key (lambda (item) (symbol-name (car item))))))

(defun quelpa-parse-stable (cache-item)
  ;; in case :stable doesn't originate from PLIST, shadow the
  ;; default value anyways
  (when (plist-member (cdr cache-item) :stable)
    (setq quelpa-stable-p (plist-get (cdr cache-item) :stable)))
  (when (and quelpa-stable-p
             (plist-member (cdr cache-item) :stable)
             (not (plist-get (cdr cache-item) :stable)))
    (setf (cdr (last cache-item)) '(:stable t))))

;;;###autoload
(defun quelpa-checkout-melpa (&optional force)
  "Fetch or update the melpa source code from Github.
If there is no error return non-nil.
If there is an error but melpa is already checked out return non-nil.
If there is an error and no existing checkout return nil.

When FORCE is non-nil we will always update MELPA regrdless of
`quelpa-update-melpa-p`."
  (interactive "p")
  (or (and (not (or force quelpa-update-melpa-p))
           (file-exists-p (expand-file-name ".git" quelpa-melpa-dir)))
      (condition-case err
          (quelpa-build--checkout-git
           'package-build
           `(:url ,quelpa-melpa-repo-url :files ("*") :partial :treeless)
           quelpa-melpa-dir)
        (error "Failed to checkout melpa git repo: `%s'" (error-message-string err)))))

(defun quelpa-get-melpa-recipe (name)
  "Read recipe with NAME for melpa git checkout.
Return the recipe if it exists, otherwise nil."
  (cl-loop for store in quelpa-melpa-recipe-stores
           if (stringp store)
           for file = (assoc-string name (directory-files store nil "^[^.].*$"))
           when file
           return (with-temp-buffer
                    (insert-file-contents-literally
                     (expand-file-name file store))
                    (read (buffer-string)))
           else
           for rcp = (assoc-string name store)
           when rcp
           return rcp))

(defun quelpa-setup-p ()
  "Setup what we need for quelpa.
Return non-nil if quelpa has been initialized properly."
  (catch 'quit
    (dolist (dir (list quelpa-packages-dir quelpa-build-dir))
      (unless (file-exists-p dir) (make-directory dir t)))
    (unless quelpa-initialized-p
      (quelpa-read-cache)
      (when (and quelpa-checkout-melpa-p
                 (not (quelpa-checkout-melpa)))
        (throw 'quit nil))
      (unless package-alist (package-load-all-descriptors))
      (setq quelpa-initialized-p t))
    t))

(defun quelpa-shutdown ()
  "Do things that need to be done after running quelpa."
  (quelpa-save-cache)
  ;; remove the packages dir because we are done with the built pkgs
  (ignore-errors (delete-directory quelpa-packages-dir t)))

(defun quelpa-arg-rcp (arg)
  "Given recipe or package name ARG, return an alist '(NAME . RCP).
If RCP cannot be found it will be set to nil"
  (pcase arg
    (`(,name) (quelpa-get-melpa-recipe name))
    (`(,name . ,_) arg)
    (name (quelpa-get-melpa-recipe name))))

(defun quelpa-parse-plist (plist)
  "Parse the optional PLIST argument of `quelpa'.
Recognized keywords are:

:upgrade

If t, `quelpa' tries to do an upgrade.

:stable

If t, `quelpa' tries building the stable version of a package.

:autoremove

If t, `quelpa' tries to remove obsoleted packages."
  (while plist
    (let ((key (car plist))
          (value (cadr plist)))
      (pcase key
        (:upgrade (setq quelpa-upgrade-p value))
        (:stable (setq quelpa-stable-p value))
        (:autoremove (setq quelpa-autoremove-p value))))
    (setq plist (cddr plist))))

(defun quelpa-package-install-file (file)
  "Workaround problem with `package-install-file'.
`package-install-file' uses `insert-file-contents-literally'
which causes problems when the FILE inserted has crlf line endings (Windows).
So here we replace that with `insert-file-contents' for non-tar files."
  (if (eq system-type 'windows-nt)
      (cl-letf* ((insert-file-contents-literally-orig
                  (symbol-function 'insert-file-contents-literally))
                 ((symbol-function 'insert-file-contents-literally)
                  (lambda (file)
                    (if (string-match "\\.tar\\'" file)
                        (funcall insert-file-contents-literally-orig file)
                      (insert-file-contents file)))))
        (package-install-file file))
    (package-install-file file)))

(defun quelpa-package-install (arg &rest plist)
  "Build and install package from ARG (a recipe or package name).
PLIST is a plist that may modify the build and/or fetch process.
If the package has dependencies recursively call this function to install them.
Return new package version."
  (let* ((rcp (quelpa-arg-rcp arg))
         (file (when rcp (quelpa-build (append rcp plist)))))
    (when file
      (let* ((pkg-desc (quelpa-get-package-desc file))
             (requires (package-desc-reqs pkg-desc))
             (ver (package-desc-version pkg-desc)))
        (when requires
          (mapc (lambda (req)
                  (unless (or (equal 'emacs (car req))
                              (quelpa--package-installed-p (car req) (cadr req)))
                    (quelpa-package-install (car req))))
                requires))
        (quelpa-package-install-file file)
        ver))))

(defun quelpa-interactive-candidate ()
  "Query the user for a recipe and return the name or recipe."
  (when (quelpa-setup-p)
    (let*  ((recipes (cl-loop
                      for store in quelpa-melpa-recipe-stores
                      if (stringp store)
                      ;; this regexp matches all files except dotfiles
                      append (directory-files store nil "^[^.].*$")
                      else if (listp store)
                      append store))
            (recipe (completing-read "Choose MELPA recipe: " recipes nil t)))
      (pcase (assoc-string recipe recipes)
        ((and re (pred stringp)) (intern re))
        (re re)))))

(defun quelpa--delete-obsoleted-package (name &optional new-version)
  "Delete obsoleted packages with name NAME.
With NEW-VERSION, will delete obsoleted packages that are not in same
version."
  (when-let ((all-pkgs (alist-get name package-alist))
             (new-pkg-version (or new-version
                                   (package-desc-version (car all-pkgs)))))
    (with-demoted-errors "Error deleting package: %S"
      (mapc (lambda (pkg-desc)
              (unless (equal (package-desc-version pkg-desc)
                             new-pkg-version)
                (let ((inhibit-message t))
                  (package-delete pkg-desc 'force))))
            all-pkgs))
    ;; Only packages with same version remained. Just pick the first one.
    (when-let (all-pkgs (alist-get name package-alist))
      (setf (cdr all-pkgs) nil))))

;; --- public interface ------------------------------------------------------

;;;###autoload
(defun quelpa-expand-recipe (recipe)
  "Expand a given RECIPE into full recipe.
If called interactively, let the user choose a recipe name and
insert the result into the current buffer."
  (interactive (list (quelpa-interactive-candidate)))
  (when (quelpa-setup-p)
    (let* ((recipe (if (listp recipe) recipe
                     (quelpa-get-melpa-recipe recipe))))
      (when recipe
        (if (called-interactively-p 'any)
            (prin1 recipe (current-buffer)))
        recipe))))

;;;###autoload
(defun quelpa-self-upgrade (&optional args)
  "Upgrade quelpa itself.
ARGS are additional options for the quelpa recipe."
  (interactive)
  (when (quelpa-setup-p)
    (quelpa (append quelpa-recipe args) :upgrade t)))

;;;###autoload
(defun quelpa-upgrade-all (&optional force)
  "Upgrade all packages found in `quelpa-cache'.
This provides an easy way to upgrade all the packages for which
the `quelpa' command has been run in the current Emacs session.
With prefix FORCE, packages will all be upgraded discarding local changes."
  (interactive "P")
  (when (quelpa-setup-p)
    (when quelpa-self-upgrade-p
      (quelpa-self-upgrade))
    (mapc (lambda (rcp)
            (quelpa-upgrade rcp (when force 'force)))
          quelpa-cache)))

;;;###autoload
(defun quelpa-upgrade (rcp &optional action)
  "Upgrade a package found in `quelpa-cache' with recipe RCP.
Optionally, ACTION can be passed for non-interactive call with value of:
- `force' (or \\[universal-argument] \\[quelpa-upgrade]) for forced upgrade.
- `local' (or \\[universal-argument] \\[universal-argument] \\[quelpa-upgrade])
  for upgrade using current working tree."
  (interactive
   (let ((prefix (prefix-numeric-value current-prefix-arg)))
     (list nil
           (cond  ((eq prefix 4) 'force)
                  ((eq prefix 16) 'local)))))
  (when (quelpa-setup-p)
    (let* ((rcp (or rcp
                    (let ((quelpa-melpa-recipe-stores
                           (list (cl-remove-if-not #'quelpa--package-installed-p
                                                   quelpa-cache :key #'car))))
                      (quelpa-interactive-candidate))))
           (quelpa-upgrade-p t)
           (current-prefix-arg nil)
           (config (append (cond ((eq action 'force) `(:force t))
                                 ((eq action 'local) `(:use-current-ref t)))
                           `(:autoremove ,quelpa-autoremove-p))))
      (when (quelpa--package-installed-p (car (quelpa-arg-rcp rcp)))
        (apply #'quelpa rcp config)))))

;;;###autoload
(defun quelpa (arg &rest plist)
  "Build and install a package with quelpa.
ARG can be a package name (symbol) or a melpa recipe (list).
PLIST is a plist that may modify the build and/or fetch process.
If called interactively, `quelpa' will prompt for a MELPA package
to install.

When `quelpa' is called interactively with a prefix argument (e.g
\\[universal-argument] \\[quelpa]) it will try to upgrade the
given package and remove any old versions of it even if the
`quelpa-upgrade-p' and `quelpa-autoremove-p' are set to nil."
  (interactive (list nil))
  (run-hooks 'quelpa-before-hook)
  (when (quelpa-setup-p) ;if init fails we do nothing
    (let* ((arg (or arg
                    (let ((quelpa-melpa-recipe-stores
                           `(,@quelpa-melpa-recipe-stores ,quelpa-cache)))
                      (quelpa-interactive-candidate))))
           (quelpa-upgrade-p (if current-prefix-arg t quelpa-upgrade-p)) ;shadow `quelpa-upgrade-p'
           (quelpa-stable-p quelpa-stable-p) ;shadow `quelpa-stable-p'
           (quelpa-autoremove-p (if current-prefix-arg t quelpa-autoremove-p))
           (cache-item (quelpa-arg-rcp arg)))
      (quelpa-parse-plist plist)
      (quelpa-parse-stable cache-item)
      (when-let ((ver (apply #'quelpa-package-install arg plist)))
        (when quelpa-autoremove-p
          (quelpa--delete-obsoleted-package (car cache-item) ver))
        (quelpa-update-cache cache-item))))
  (quelpa-shutdown)
  (run-hooks 'quelpa-after-hook))

;;;###autoload
(defun quelpa-upgrade-all-maybe (&optional force)
  "Run `quelpa-upgrade-all' if at least `quelpa-upgrade-interval' days have passed since the last run.
With prefix FORCE, packages will all be upgraded discarding local changes."
  (interactive "P")
  (when quelpa-upgrade-interval
    (let ((timestamp (expand-file-name "last_upgrade" quelpa-dir)))
      (when (or (not (file-exists-p timestamp))
                (> (- (time-to-seconds) ; Current time - modification time.
                      (time-to-seconds (nth 5 (file-attributes timestamp))))
                   (* 60 60 24 quelpa-upgrade-interval)))
        (quelpa-upgrade-all force)
        (write-region "" nil timestamp)))))

(provide 'quelpa)

;;; quelpa.el ends here
#+end_src

** straight-config.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;; Adapted From: https://github.com/raxod502/straight.el#how-do-i-pin-package-versions-or-use-only-tagged-releases
;; And: https://www.reddit.com/r/emacs/comments/dppmqj/do_i_even_need_to_leverage_earlyinitel_if_i_have/?utm_source=amp&utm_medium=&utm_content=post_body
;; And: https://github.com/hartzell/straight.el/commit/882649137f73998d60741c7c8c993c7ebbe0f77a#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5R1649

(setq straight-profiles
      '((nil . "default.el")
        (pinned . "pinned.el")))

(with-no-warnings
    (setq straight-vc-git-default-clone-depth 1)
    (setq straight-base-dir (concat pre-user-emacs-directory ".local/"))
    (setq straight-repository-branch "develop")
    (setq straight-build-dir (format "build-%s" emacs-version))
    (setq straight-cache-autoloads t)
    (setq straight-check-for-modifications '(check-on-save find-when-checking))
    ;; (setq straight-use-package-by-default t)
    (setq straight-disable-byte-compilation (member "--no-byte-compilation" command-line-args)))

(delete "--no-byte-compilation" command-line-args)

(eval-and-compile
  (setq straight-recipes-gnu-elpa-use-mirror t)
  (setq straight-recipes-emacsmirror-use-mirror t)
  (setq bootstrap-version 5)
  (setq bootstrap-file (concat straight-base-dir "straight/repos/straight.el/bootstrap.el")))

(unless (file-exists-p bootstrap-file)
  (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
       'silent 'inhibit-cookies)
    (goto-char (point-max))
    (eval-print-last-sexp)))

(load bootstrap-file nil 'nomessage)

(autoload #'straight-x-pull-all "straight-x")
(autoload #'straight-x-freeze-versions "straight-x")
#+end_src

** package-config.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
(require 'package)
(add-to-list 'package-archives (cons "melpa" "https://melpa.org/packages/") t)
(setq package-selected-packages '(borg))
(when (require 'borg nil t) (package-install 'borg) (require 'borg))
(if (require 'borg-elpa nil t) (borg-elpa-initialize) (package-initialize))
#+end_src

** scroll-bar.el

#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; scroll-bar.el --- window system-independent scroll bar support  -*- lexical-binding: t; -*-

;; Copyright (C) 1993-1995, 1999-2021 Free Software Foundation, Inc.

;; Maintainer: emacs-devel@gnu.org
;; Keywords: hardware
;; Package: emacs

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; Window-system-independent bindings of mouse clicks on the scroll bar.
;; Presently emulates the scroll-bar behavior of xterm.

;;; Code:

(require 'mouse)
(eval-when-compile (require 'cl-lib))


;;;; Utilities.

(defun scroll-bar-event-ratio (event)
  "Given a scroll bar event EVENT, return the scroll bar position as a ratio.
The value is a cons cell (PORTION . WHOLE) containing two integers
whose ratio gives the event's vertical position in the scroll bar, with 0
referring to the top and 1 to the bottom."
  (nth 2 event))

(defun scroll-bar-scale (num-denom whole)
  "Given a pair (NUM . DENOM) and WHOLE, return (/ (* NUM WHOLE) DENOM).
This is handy for scaling a position on a scroll bar into real units,
like buffer positions.  If SCROLL-BAR-POS is the (PORTION . WHOLE) pair
from a scroll bar event, then (scroll-bar-scale SCROLL-BAR-POS
\(buffer-size)) is the position in the current buffer corresponding to
that scroll bar position."
  ;; We multiply before we divide to maintain precision.
  (truncate (* (car num-denom) whole) (cdr num-denom)))

(defun scroll-bar-columns (side)
  "Return the width, measured in columns, of the vertical scrollbar on SIDE.
SIDE must be the symbol `left' or `right'."
  (let* ((wsb   (window-scroll-bars))
         (vtype (nth 2 wsb))
         (cols  (nth 1 wsb)))
    (cond
     ((not (memq side '(left right)))
      (error "`left' or `right' expected instead of %S" side))
     ((and (eq vtype side) cols))
     ((eq (frame-parameter nil 'vertical-scroll-bars) side)
      ;; nil means it's a non-toolkit scroll bar, and its width in
      ;; columns is 14 pixels rounded up.
      (ceiling (or (frame-parameter nil 'scroll-bar-width) 14)
               (frame-char-width)))
     (0))))

(defun scroll-bar-lines ()
  "Return the height, measured in lines, of the horizontal scrollbar."
  (let* ((wsb   (window-scroll-bars))
         (htype (nth 5 wsb))
         (lines  (nth 4 wsb)))
    (cond
     (htype lines)
     ((frame-parameter nil 'horizontal-scroll-bars)
      ;; nil means it's a non-toolkit scroll bar (which is currently
      ;; impossible), and its height in lines is 14 pixels rounded up.
      (ceiling (or (frame-parameter nil 'scroll-bar-height) 14)
               (frame-char-width)))
     (0))))


;;;; Helpful functions for enabling and disabling scroll bars.

(defvar scroll-bar-mode)
(defvar horizontal-scroll-bar-mode)
(defvar previous-scroll-bar-mode nil)

(defvar scroll-bar-mode-explicit nil
  "Non-nil means `set-scroll-bar-mode' should really do something.
This is nil while loading `scroll-bar.el', and t afterward.")

(defun set-scroll-bar-mode (value)
  "Set the scroll bar mode to VALUE and put the new value into effect.
See the `scroll-bar-mode' variable for possible values to use."
  (if scroll-bar-mode
      (setq previous-scroll-bar-mode scroll-bar-mode))

  (setq scroll-bar-mode value)

  (when scroll-bar-mode-explicit
    (modify-all-frames-parameters (list (cons 'vertical-scroll-bars
					      scroll-bar-mode)))))

(defcustom scroll-bar-mode default-frame-scroll-bars
  "Specify whether to have vertical scroll bars, and on which side.
Possible values are nil (no scroll bars), `left' (scroll bars on left)
and `right' (scroll bars on right).
To set this variable in a Lisp program, use `set-scroll-bar-mode'
to make it take real effect.
Setting the variable with a customization buffer also takes effect."
  :type '(choice (const :tag "none (nil)" nil)
		 (const left)
		 (const right))
  :group 'frames
  ;; The default value for :initialize would try to use :set
  ;; when processing the file in cus-dep.el.
  :initialize 'custom-initialize-default
  :set (lambda (_sym val) (set-scroll-bar-mode val)))

;; We just set scroll-bar-mode, but that was the default.
;; If it is set again, that is for real.
(setq scroll-bar-mode-explicit t)

(defun get-scroll-bar-mode ()
  (declare (gv-setter set-scroll-bar-mode))
  scroll-bar-mode)

(define-minor-mode scroll-bar-mode
  "Toggle vertical scroll bars on all frames (Scroll Bar mode).

This command applies to all frames that exist and frames to be
created in the future."
  :variable ((get-scroll-bar-mode)
             . (lambda (v) (set-scroll-bar-mode
			    (if v (or previous-scroll-bar-mode
				      default-frame-scroll-bars))))))

(defun horizontal-scroll-bars-available-p ()
  "Return non-nil when horizontal scroll bars are available on this system."
  (and (display-graphic-p)
       (boundp 'x-toolkit-scroll-bars)
       x-toolkit-scroll-bars))

(define-minor-mode horizontal-scroll-bar-mode
  "Toggle horizontal scroll bars on all frames (Horizontal Scroll Bar mode).

This command applies to all frames that exist and frames to be
created in the future."
  :init-value nil
  :global t
  :group 'frames
  (if (and horizontal-scroll-bar-mode
	   (not (horizontal-scroll-bars-available-p)))
      (progn
	(setq horizontal-scroll-bar-mode nil)
	(message "Horizontal scroll bars are not implemented on this system"))
    (dolist (frame (frame-list))
      (set-frame-parameter
       frame 'horizontal-scroll-bars horizontal-scroll-bar-mode))
    ;; Handle `default-frame-alist' entry.
    (setq default-frame-alist
	  (cons (cons 'horizontal-scroll-bars horizontal-scroll-bar-mode)
		(assq-delete-all 'horizontal-scroll-bars
				 default-frame-alist)))))

(defun toggle-scroll-bar (arg)
  "Toggle whether or not the selected frame has vertical scroll bars.
With ARG, turn vertical scroll bars on if and only if ARG is positive.
The variable `scroll-bar-mode' controls which side the scroll bars are on
when they are turned on; if it is nil, they go on the left."
  (interactive "P")
  (if (null arg)
      (setq arg
	    (if (frame-parameter nil 'vertical-scroll-bars) -1 1))
    (setq arg (prefix-numeric-value arg)))
  (modify-frame-parameters
   (selected-frame)
   (list (cons 'vertical-scroll-bars
	       (if (> arg 0)
		   (or scroll-bar-mode default-frame-scroll-bars))))))

(defun toggle-horizontal-scroll-bar (arg)
  "Toggle whether or not the selected frame has horizontal scroll bars.
With ARG, turn vertical scroll bars on if and only if ARG is positive."
  (interactive "P")
  (if (null arg)
      (setq arg
	    (if (frame-parameter nil 'horizontal-scroll-bars) -1 1))
    (setq arg (prefix-numeric-value arg)))
  (modify-frame-parameters
   (selected-frame)
   (list (cons 'horizontal-scroll-bars
	       (when (> arg 0) 'bottom)))))

;;;; Buffer navigation using the scroll bar.

;; This was used for up-events on button 2, but no longer.
(defun scroll-bar-set-window-start (event)
  "Set the window start according to where the scroll bar is dragged.
EVENT should be a scroll bar click or drag event."
  (interactive "e")
  (let* ((end-position (event-end event))
	 (window (nth 0 end-position))
	 (portion-whole (nth 2 end-position)))
    (with-current-buffer (window-buffer window)
      (save-excursion
	(goto-char (+ (point-min)
		      (scroll-bar-scale portion-whole
					(- (point-max) (point-min)))))
	(beginning-of-line)
	(set-window-start window (point))))))

(defun scroll-bar-drag-position (portion-whole)
  "Calculate new window start for drag event."
  (save-excursion
    (goto-char (+ (point-min)
		  (scroll-bar-scale portion-whole
				    (- (point-max) (point-min)))))
    (beginning-of-line)
    (point)))

(defun scroll-bar-maybe-set-window-start (event)
  "Set the window start according to where the scroll bar is dragged.
Only change window start if the new start is substantially different.
EVENT should be a scroll bar click or drag event."
  (interactive "e")
  (let* ((end-position (event-end event))
	 (window (nth 0 end-position))
	 (portion-whole (nth 2 end-position))
	 (next-portion-whole (cons (1+ (car portion-whole))
				   (cdr portion-whole)))
	 portion-start
	 next-portion-start
	 (current-start (window-start window)))
    (with-current-buffer (window-buffer window)
      (setq portion-start (scroll-bar-drag-position portion-whole))
      (setq next-portion-start (max
				(scroll-bar-drag-position next-portion-whole)
				(1+ portion-start)))
      (if (or (>= current-start next-portion-start)
	      (< current-start portion-start))
	  (set-window-start window portion-start)
	;; Always set window start, to ensure scroll bar position is updated.
	(set-window-start window current-start)))))

;; Scroll the window to the proper position for EVENT.
(defun scroll-bar-drag-1 (event)
  (let* ((start-position (event-start event))
	 (window (nth 0 start-position))
	 (portion-whole (nth 2 start-position)))
    ;; With 'scroll-bar-adjust-thumb-portion' nil and 'portion-whole'
    ;; indicating that the buffer is fully visible, do not scroll the
    ;; window since that might make it impossible to scroll it back
    ;; with GTK's thumb (Bug#32002).
    (when (or scroll-bar-adjust-thumb-portion
              (not (numberp (car portion-whole)))
              (not (numberp (cdr portion-whole)))
              (/= (car portion-whole) (cdr portion-whole)))
      (save-excursion
        (with-current-buffer (window-buffer window)
	  ;; Calculate position relative to the accessible part of the buffer.
	  (goto-char (+ (point-min)
		        (scroll-bar-scale portion-whole
					  (- (point-max) (point-min)))))
	  (vertical-motion 0 window)
	  (set-window-start window (point)))))))

(defun scroll-bar-drag (event)
  "Scroll the window by dragging the scroll bar slider.
If you click outside the slider, the window scrolls to bring the slider there."
  (interactive "e")
  (let* (done
	 (echo-keystrokes 0)
	 (end-position (event-end event))
	 (window (nth 0 end-position))
	 (before-scroll))
    (with-current-buffer (window-buffer window)
      (setq before-scroll point-before-scroll))
    (save-selected-window
      (select-window window 'mark-for-redisplay)
      (setq before-scroll
	    (or before-scroll (point))))
    (scroll-bar-drag-1 event)
    (track-mouse
      (while (not done)
	(setq event (read-event))
	(if (eq (car-safe event) 'mouse-movement)
	    (setq event (read-event)))
	(cond ((eq (car-safe event) 'scroll-bar-movement)
	       (scroll-bar-drag-1 event))
	      (t
	       ;; Exit when we get the drag event; ignore that event.
	       (setq done t)))))
    (sit-for 0)
    (with-current-buffer (window-buffer window)
      (setq point-before-scroll before-scroll))))

;; Scroll the window to the proper position for EVENT.
(defun scroll-bar-horizontal-drag-1 (event)
  (let* ((start-position (event-start event))
	 (window (nth 0 start-position))
	 (portion-whole (nth 2 start-position))
	 (unit (frame-char-width (window-frame window))))
    (if (eq (current-bidi-paragraph-direction (window-buffer window))
	    'left-to-right)
	(set-window-hscroll
	 window (/ (+ (car portion-whole) (1- unit)) unit))
      (set-window-hscroll
       window (/ (+ (- (cdr portion-whole) (car portion-whole))
		    (1- unit))
		 unit)))))

(defun scroll-bar-horizontal-drag (event)
  "Scroll the window horizontally by dragging the scroll bar slider.
If you click outside the slider, the window scrolls to bring the slider there."
  (interactive "e")
  (let* (done
	 (echo-keystrokes 0)
	 (end-position (event-end event))
	 (window (nth 0 end-position))
	 (before-scroll))
    (with-current-buffer (window-buffer window)
      (setq before-scroll point-before-scroll))
    (save-selected-window
      (select-window window 'mark-for-redisplay)
      (setq before-scroll
	    (or before-scroll (point))))
    (scroll-bar-horizontal-drag-1 event)
    (track-mouse
      (while (not done)
	(setq event (read-event))
	(if (eq (car-safe event) 'mouse-movement)
	    (setq event (read-event)))
	(cond ((eq (car-safe event) 'scroll-bar-movement)
	       (scroll-bar-horizontal-drag-1 event))
	      (t
	       ;; Exit when we get the drag event; ignore that event.
	       (setq done t)))))
    (sit-for 0)
    (with-current-buffer (window-buffer window)
      (setq point-before-scroll before-scroll))))

(defun scroll-bar-scroll-down (event)
  "Scroll the window's top line down to the location of the scroll bar click.
EVENT should be a scroll bar click."
  (interactive "e")
  (let* ((end-position (event-end event))
	 (window (nth 0 end-position))
	 (before-scroll))
    (with-current-buffer (window-buffer window)
      (setq before-scroll point-before-scroll))
    (unwind-protect
	(save-selected-window
	  (let ((portion-whole (nth 2 end-position)))
	    (select-window window 'mark-for-redisplay)
	    (setq before-scroll
		  (or before-scroll (point)))
	    (scroll-down
	     (scroll-bar-scale portion-whole (1- (window-height)))))
	  (sit-for 0))
      (with-current-buffer (window-buffer window)
	(setq point-before-scroll before-scroll)))))

(defun scroll-bar-scroll-up (event)
  "Scroll the line next to the scroll bar click to the top of the window.
EVENT should be a scroll bar click."
  (interactive "e")
  (let* ((end-position (event-end event))
	 (window (nth 0 end-position))
	 (before-scroll))
    (with-current-buffer (window-buffer window)
      (setq before-scroll point-before-scroll))
    (unwind-protect
	(save-selected-window
	  (let ((portion-whole (nth 2 end-position)))
	    (select-window window 'mark-for-redisplay)
	    (setq before-scroll
		  (or before-scroll (point)))
	    (scroll-up
	     (scroll-bar-scale portion-whole (1- (window-height)))))
	  (sit-for 0))
      (with-current-buffer (window-buffer window)
	(setq point-before-scroll before-scroll)))))


;;; Tookit scroll bars.

(defun scroll-bar-toolkit-scroll (event)
  "Handle event EVENT on vertical scroll bar."
  (interactive "e")
  (let* ((end-position (event-end event))
	 (window (nth 0 end-position))
	 (part (nth 4 end-position))
	 before-scroll)
    (cond
     ((eq part 'end-scroll))
     (t
      (with-current-buffer (window-buffer window)
	(setq before-scroll point-before-scroll))
      (save-selected-window
	(select-window window 'mark-for-redisplay)
	(setq before-scroll (or before-scroll (point)))
	(cond
	 ((eq part 'above-handle)
	  (scroll-up '-))
	 ((eq part 'below-handle)
	  (scroll-up nil))
	 ((eq part 'ratio)
	  (let* ((portion-whole (nth 2 end-position))
		 (lines (scroll-bar-scale portion-whole
					  (1- (window-height)))))
	    (scroll-up (cond ((not (zerop lines)) lines)
			     ((< (car portion-whole) 0) -1)
			     (t 1)))))
	 ((eq part 'up)
	  (scroll-up -1))
	 ((eq part 'down)
	  (scroll-up 1))
	 ((eq part 'top)
	  (set-window-start window (point-min)))
	 ((eq part 'bottom)
	  (goto-char (point-max))
	  (recenter))
	 ((eq part 'handle)
	  (scroll-bar-drag-1 event))))
      (sit-for 0)
      (with-current-buffer (window-buffer window)
	(setq point-before-scroll before-scroll))))))

(defun scroll-bar-toolkit-horizontal-scroll (event)
  "Handle event EVENT on horizontal scroll bar."
  (interactive "e")
  (let* ((end-position (event-end event))
	 (window (nth 0 end-position))
	 (part (nth 4 end-position))
	 (bidi-factor
	  (if (eq (current-bidi-paragraph-direction (window-buffer window))
		  'left-to-right)
	      1
	    -1))
	 before-scroll)
    (cond
     ((eq part 'end-scroll))
     (t
      (with-current-buffer (window-buffer window)
	(setq before-scroll point-before-scroll))
      (save-selected-window
	(select-window window 'mark-for-redisplay)
	(setq before-scroll (or before-scroll (point)))
	(cond
	 ((eq part 'before-handle)
	  (scroll-right (* bidi-factor 4)))
	 ((eq part 'after-handle)
	  (scroll-left (* bidi-factor 4)))
	 ((eq part 'ratio)
	  (let* ((portion-whole (nth 2 end-position))
		 (columns (scroll-bar-scale portion-whole
					    (1- (window-width)))))
	    (scroll-right
	     (* (cond
		 ((not (zerop columns))
		  columns)
		 ((< (car portion-whole) 0) -1)
		 (t 1))
		bidi-factor))))
	 ((eq part 'left)
	  (scroll-right (* bidi-factor 1)))
	 ((eq part 'right)
	  (scroll-left (* bidi-factor 1)))
	 ((eq part 'leftmost)
	  (goto-char (if (eq bidi-factor 1)
			 (line-beginning-position)
		       (line-end-position))))
	 ((eq part 'rightmost)
	  (goto-char (if (eq bidi-factor 1)
			 (line-end-position)
		       (line-beginning-position))))
	 ((eq part 'horizontal-handle)
	  (scroll-bar-horizontal-drag-1 event))))
      (sit-for 0)
      (with-current-buffer (window-buffer window)
	(setq point-before-scroll before-scroll))))))

;;;; Bindings.

;; For now, we'll set things up to work like xterm.
(cond ((and (boundp 'x-toolkit-scroll-bars) x-toolkit-scroll-bars)
       (global-set-key [vertical-scroll-bar mouse-1]
		       'scroll-bar-toolkit-scroll)
       (global-set-key [horizontal-scroll-bar mouse-1]
		       'scroll-bar-toolkit-horizontal-scroll))
      (t
       (global-set-key [vertical-scroll-bar mouse-1]
		       'scroll-bar-scroll-up)
       (global-set-key [vertical-scroll-bar drag-mouse-1]
		       'scroll-bar-scroll-up)
       (global-set-key [vertical-scroll-bar down-mouse-2]
		       'scroll-bar-drag)
       (global-set-key [vertical-scroll-bar mouse-3]
		       'scroll-bar-scroll-down)
       (global-set-key [vertical-scroll-bar drag-mouse-3]
		       'scroll-bar-scroll-down)))


(provide 'scroll-bar)

;;; scroll-bar.el ends here
#+end_src
